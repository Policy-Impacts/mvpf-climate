----------------------------------------------------------------------------------
      name:  <unnamed>
       log:  C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/0_log/log_metafile
> _2025-07-28_21-01-53__full_current_no_lbd.log
  log type:  text
 opened on:  28 Jul 2025, 21:01:53

. // create new folders
. cap mkdir "${results}"

. 
. 
. *-----------------------------------------------------------------------
. * 0 - Define Macros.
. *-----------------------------------------------------------------------
. 
. foreach correction_mode of global correction_modes {
  2.     global correction_mode `correction_mode'
  3.     global nrun = "${nrun}_`correction_mode'"
  4.     global causal_ests = "${code_files}/2a_causal_estimates_papers/`correctio
> n_mode'"
  5.     global causal_draws = "${code_files}/2b_causal_estimates_draws/`correctio
> n_mode'"
  6. 
.     if $usets == 1 {
  7.         global stamp = "${timestamp}__${nrun}"
  8.     }
  9.     else {
 10.         global stamp = "${nrun}"
 11.     }
 12.     // Set results to use
.     if "$use_causal_draws" == "redraw" {
 13.         global redraw_causal_estimates = "yes"
 14.         global ts_causal_draws = "${stamp}"
 15.         noi di "Create new causal draws: ${ts_causal_draws}"
 16.         cap mkdir "${causal_draws}/${ts_causal_draws}"
 17.     }
 18.     else if "$use_causal_draws" == "latest" {
 19.         global redraw_causal_estimates = "no"
 20.         local folders : dir "${causal_draws}" dirs "*"
 21.         global ts_causal_draws : word `:list sizeof folders' of `folders'
 22.         noi di "Using latest causal draws: `ts_causal_draws'."
 23.     }
 24.     else {
 25.         global redraw_causal_estimates = "no"
 26.         global ts_causal_draws = "$use_causal_draws"
 27.         noi di "Using specific causal draws: `ts_causal_draws'."
 28.     }
 29.     /* Note: There is no "redraw bootstrap draws" option at the moment. */
.     if "$use_bootstrap_draws" == "redraw" {
 30.         global redraw_bootstrap_estimates = "yes"
 31.         global ts_bootstrap_draws = "${stamp}"
 32.         noi di "Create new bootstrap draws: ${ts_bootstrap_draws}"
 33.         cap mkdir "${bootstrap_folder}/${ts_bootstrap_draws}"
 34.     }
 35.     else if "$use_bootstrap_draws" == "latest" {
 36.         global redraw_bootstrap_estimates = "no"
 37.         local folders : dir "${bootstrap_folder}" dirs "*"
 38.         global ts_bootstrap_draws : word `:list sizeof folders' of `folders'
 39.         noi di "Using latest bootstrap draws: `ts_bootstrap_draws'."
 40.     }
 41.     else {
 42.         global redraw_bootstrap_estimates = "no"
 43.         global ts_bootstrap_draws = "$use_bootstrap_draws"
 44.         noi di "Using specific bootstrap draws: `ts_bootstrap_draws'."
 45.     }
 46. 
.     global bootstrap_files = "${bootstrap_folder}/${ts_bootstrap_draws}"
 47.     global append_files = "${bootstrap_files}/all_policies_collated"
 48.     cap mkdir "${bootstrap_files}"
 49.     cap mkdir "${append_files}"
 50. 
. 
.     local programs_to_run $programs_to_run
 51.     local programs_pb_exclude $programs_pb_exclude
 52.     if "`correction_mode'" == "corrected" global programs_to_run: list progra
> ms_to_run - programs_pb_exclude
 53. 
.     if "`correction_mode'" == "corrected"{
 54.         di in red "the list of programs is ${programs_to_run}"
 55.     }
 56. 
.     *-----------------------------------------------------------------------
.     * 0 - Macros
.     *-----------------------------------------------------------------------
.     noi di "SECTION 0: MACROS"
 57.         qui do "${github}/ado/check_timepaths.ado"
 58.     qui do "${github}/wrapper/macros.do" "yes"
 59. 
.     *-----------------------------------------------------------------------
.     * 1 - Prepare causal estimates
.     *-----------------------------------------------------------------------
.     noi di "SECTION 1: PREPARE CAUSAL ESTIMATES"
 60.     * 1 - prepare bootstrap draws of uncorrected causal estimates
.     noi do "${github}/wrapper/prepare_causal_estimates.do" ///
>            "$programs_to_run" // programs to run / all_programs
 61. 
.     *-----------------------------------------------------------------------
.     * 2 - Estimate MVPFs and other statistics, bootstrap, and loop through globa
> l assumptions
.     *-----------------------------------------------------------------------
. 
.     noi di "SECTION 2: ESTIMATION & BOOTSTRAPPING"
 62.         
.     do "${github}/wrapper/bootstrap_wrapper.do" ///
>        "${programs_to_run}" /// programs to run
>        "${modes_to_run}" // all_modes // baseline // modes to run
 63. 
.     if "${make_waterfall}" == "yes"{
 64.         do "${github}/wrapper/waterfalls.do" ///
>            "${programs_to_run}" /// programs to run
>            "${modes_to_run}" // all_modes // baseline // modes to run
 65.     }
 66. 
.     *-----------------------------------------------------------------------
.     * 3 - Compile results.
.     *-----------------------------------------------------------------------
.     noi di "SECTION 3: COMPILE ESTIMATES & INFERENCE"
 67.     clear
 68. 
.     di in red "compile programs is ${compile_programs}"
 69.     di in red "compile loop modes is ${compile_loop_modes}"
 70.     foreach program of global compile_programs {
 71. 
.         di "${compile_loop_modes}"              
 72.         foreach mode of global compile_loop_modes {
 73.             append using "${bootstrap_files}/`program'_`mode'_estimates_${rep
> lications}_replications"   
 74.         }
 75. 
.     }
 76.     save "${results}/compiled_results_all_`correction_mode'", replace 
 77. 
. 
.     /*-----------------------------------------------------------------------
>     * 4 - Append with Previous Run
>     *-----------------------------------------------------------------------*/
. 
.     if "${append}" == "yes" {
 78.         
.         use "${code_files}/4_results/${original_stamp}/compiled_results_all_`cor
> rection_mode'", clear 
 79. 
.         foreach mode of global compile_loop_modes {
 80.             foreach program of global compile_programs {
 81.                 drop if program == "`program'" & assumptions == "`mode'"     
>    
 82.         
.             if "`mode'" == "baseline" {
 83.                 append using "${bootstrap_files}/`program'_`mode'_estimates_$
> {replications}_replications"
 84.                 }
 85.             else {
 86.                 append using "${bootstrap_files}/`program'_`mode'_estimates_$
> {replications}_replications"       
 87.                 }       
 88.             }
 89.         }
 90.         
.         save "${code_files}/4_results/${original_stamp}/compiled_results_all_`co
> rrection_mode'", replace
 91.     }
 92. 
. 
. 
.     *run publication bias metafile
.     if "`9'" == "yes"{
 93.         if "`correction_mode'" == "uncorrected_vJK" do "${github}/publication
> _bias/pub_bias_wrapper"
 94.     }
 95. 
. }
Create new causal draws: 2025-07-28_21-01-53__full_current_no_lbd_uncorrected_vJK
Create new bootstrap draws: 2025-07-28_21-01-53__full_current_no_lbd_uncorrected_v
> JK
SECTION 0: MACROS
Rerun macros set to yes through a positional argument
Rerun timepaths set to no
Asked to Resave CPI Globals
Asked to Resave VMT Rebound
Asked to Resave EV Price Elasticity (Gas Tax LBD)
Asked to Rerun Gasoline Prices, Taxes, and Markups
Asked to Rerun Vehicle VMT Datasets
Discount Rate is 2%
Social Cost of Carbon is $193
Grid Type is mid
Asked to Rerun Electricity and Natural Gas Externalities
Asked to Rerun Gasoline Vehicle Externalities
Asked to Rerun Diesel Externalities
Asked to Rerun Benefits from Not Driving Gasoline-powered Vehicle
Asked to Rerun Damages from Charging Electric Vehicles
Setting globals to no because macros has finished running
SECTION 1: PREPARE CAUSAL ESTIMATES

. ********************************************************************************
. *                                               PREPARE CAUSAL ESTIMATES        
>                                                    *
. ********************************************************************************
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: "ct_solar"

. 
. * Set options
. local replications ${reps}

. local correlation 1

. 
. *-------------------------------------------------------------------------------
. *       0. Define programs to run for
. *-------------------------------------------------------------------------------
. 
. if "`1'" == ""{ // file not being run externally
. 
.         global nrun = ""
.         global stamp = "${nrun}"
.         global redraw_causal_estimates = "yes"
.     global ts_causal_draws = "${stamp}"
.     cap mkdir "${causal_draws}/${ts_causal_draws}"
. }

. 
. 
. *Allow file to be ran externally from metafile
. if "`1'" != "" { // file is being run externally
.         local programs "`1'"
. 
. }

. 
. *Set the seed to the value defined in the metafile
. confirm number ${welfare_seed}

. set seed ${welfare_seed}

. 
. *Loop over programs
. foreach program in `programs' {
  2. 
.         set seed ${welfare_seed}
  3. 
.         *check if draws exist
.         cap confirm file "${causal_draws}/${ts_causal_draws}/`program'.dta"
  4.  
.         if _rc == 0 & "${redraw_causal_estimates}" != "yes" {
  5.                 di in red "Skipping redrawing for `program'"
  6.                 continue
  7.         }
  8. 
.         noi di "`program' "
  9. 
.         import excel "${causal_ests}/`program'.xlsx", clear sheet("wrapper_ready
> ") firstrow
 10.         sort estimate
 11. 
.         *Get SE from t-stat
.         replace se = abs(pe / t_stat) if se == . & t_stat != .
 12. 
.         *Get SE from ci range (Assumed to be 95% CI)
.         replace se = ((ci_hi - ci_lo) / 2) / invnormal(0.975) if se == . & ci_lo
>  != . & ci_hi != .
 13. 
.         *Allow for p-value ranges
.         cap tostring p_value, replace force
 14.         g p_value_range = p_value if regexm(p_value,"\[")|regexm(p_value,"\]"
> )
 15.         replace p_value = "" if p_value_range != ""
 16.         destring p_value, replace force
 17.         replace se = abs(pe / invnormal(p_value/2)) if p_value_range == "" & 
> se == .
 18.         g p_val_low = strtrim(substr(p_value_range,strpos(p_value_range,"[")+
> 1,strpos(p_value_range,";")-strpos(p_value_range,"[")-1)) if p_value_range != ""
 19.         g p_val_high = strtrim(substr(p_value_range,strpos(p_value_range,";")
> +1,strpos(p_value_range,"]")-strpos(p_value_range,";")-1)) if p_value_range != "
> "
 20.         destring p_val_low p_val_high, replace
 21.         drop if estimate == ""
 22. 
.         *Get PE matrix
.         mkmat pe, matrix(pes) // just turns the column of estimates into a matri
> x
 23. 
.         *Get correlation matrix
.         /* Here blocks are indicated by different base numbers and the sign dete
> rmines
>         the correlation direction. E.g. if we have four variables with corr_dire
> ctions
>         1, -1, 2, 2 respectively, then 1 and 2 are negatively correlated, 3 and 
> 4 are
>         positively correlated, and 1 and 2 are uncorrelated with 3 and 4. */
. 
.         matrix corr = J(`=_N', `=_N', 0)
 24.         matlist corr
 25.         local namelist
 26.         forval j = 1/`=_N' {
 27.                 local name_`j' = estimate[`j']
 28.                 forval k = 1/`=_N' {
 29.                         if `j' == `k' matrix corr[`j',`k'] = 1
 30.                         else {
 31.                                 if abs(corr_direction[`j'])==abs(corr_directi
> on[`k']) {
 32.                                         matrix corr[`j', `k'] = sign(corr_dir
> ection[`j'] * corr_direction[`k']) * `correlation'
 33.                                 }
 34.                         else matrix corr[`j',`k'] = 0
 35.                         }
 36.                 }
 37.                 local namelist `namelist' `name_`j''
 38.         }       
 39. 
.         *Loop over replications to get SE matrix (can vary due to p-value ranges
> )
.         forval i = 1/`replications' {
 40.                 matrix se_`i' = J(`=_N', 1, 0)
 41.                 forval j = 1/`=_N' {
 42.                         if se[`j']!=. {
 43.                                 matrix se_`i'[`j',1] = se[`j']
 44.                         }
 45.                         if se[`j'] == . & p_value_range[`j'] != "" {
 46.                                 matrix se_`i'[`j',1] = abs(pe[`j'] / invnorma
> l(runiform(p_val_low[`j'],min(p_val_high[`j'],0.9))/2))
 47.                         }
 48.                 }               
 49.         }
 50.         qui{
 51.                 *Draw uncorrected, save dataset 
.                 forval i = 1/`replications' {
 52.                         clear
 53.                         set obs 1
 54.                         drawnorm "`namelist'", n(1) sds(se_`i') corr(corr) me
> ans(pes)
 55.                         local j = 0
 56.                         foreach var in `namelist' {
 57.                                 local ++j
 58.                                 g `var'_pe = pes[`j',1]
 59.                         }
 60.                         tempfile temp`i'
 61.                         save `temp`i''
 62.                 }
 63. 
.                 forval i = 1/`=`replications'-1' {
 64.                         append using `temp`i''
 65.                 }
 66.         }
 67. 
.         g draw_number = _n
 68.         order draw_number, first
 69. 
.         save "${causal_draws}/${ts_causal_draws}/`program'.dta", replace
 70. 
.         if _rc>0 {
 71.                 if _rc==1 continue, break
 72.                 di _rc
 73.                 local error_progs = "`error_progs'"+"`program'  "
 74.                 di as err "`program' broke"
 75.         }
 76. 
. }
ct_solar 
(12 vars, 3 obs)
(0 real changes made)
(0 real changes made)
(3 missing values generated)
(0 real changes made)
p_value: all characters numeric; replaced as byte
(3 missing values generated)
(0 real changes made)
(3 missing values generated)
(3 missing values generated)
p_val_low: all characters numeric; replaced as byte
(3 missing values generated)
p_val_high: all characters numeric; replaced as byte
(3 missing values generated)
(0 observations deleted)

             |        c1         c2         c3 
-------------+--------------------------------
          r1 |         0                       
          r2 |         0          0            
          r3 |         0          0          0 
(file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/2b_causal_estimates_draws
    > /uncorrected_vJK/2025-07-28_21-01-53__full_current_no_lbd_uncorrected_vJK/
    > ct_solar.dta not found)
file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/2b_causal_estimates_draws
    > /uncorrected_vJK/2025-07-28_21-01-53__full_current_no_lbd_uncorrected_vJK/
    > ct_solar.dta saved

. 
. *Throw errors if things didn't run
. if _rc!=1 {
.         global error_progs = "`error_progs'"
.         if "`error_progs'"!="" di as err "Finished running but the following pro
> grams threw errors: `error_progs'"
.         else di in red "Finished running with no errors"
Finished running with no errors
. }

. 
. 
. 
. 
. 
. 
. 
. 
end of do-file
SECTION 2: ESTIMATION & BOOTSTRAPPING

. ********************************************************************************
. *                                                               BOOTSTRAP WRAPPE
> R                                                          *
. ********************************************************************************
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: "ct_solar" "current"

. *Set options
. local debug = 1 // 1 noisily displays running .do files

. 
. *Set modes
. local modes "all"

. 
. /*
> Note: modes can contain any of the following:
> - baseline: only runs the baseline specification
> - current: only runs the 2020 specification
> */
. 
. // macro list
. *Set modes if running externally
. if "`2'"!="" local modes "`2'"

. 
. *Set all
. if "`modes'"=="all" local modes baseline current

. global compile_loop_modes "`modes'"

. 
. *Set estimates to be used
. local use_estimates $correction_mode

. 
. *-------------------------------------------------------------------------------
. *       0. Define programs to run for
. *-------------------------------------------------------------------------------
. global compile_programs `1'

. *Set programs if running externally
. if "`1'" != "" {
.         local programs "`1'"
. }

. 
. local prog_num = wordcount("`programs'")

. 
. *-------------------------------------------------------------------------------
. *       1. Simulations
. *-------------------------------------------------------------------------------
. global replications_master = $reps

. 
. foreach mode in `modes' {
  2.         di in red "the mode is `mode'"
  3. 
.         local m = 0 // reset counter
  4.         global replications $replications_master
  5.         local replications $reps
  6. 
.         ********** Looping through each program **********
. 
.         mat t`mode'=J(11, 5, .)
  7.         local x = 1
  8.         foreach program in `programs' {
  9. 
.                 *Sort issues where names of assumption files don't line up with 
> do file names
.                 local do_file = "`program'"
 10.                 local assumption_name = "`program'"
 11. 
.                 *Import program specific assumptions
.                 import excel "${assumptions}/program_specific/`assumption_name'.
> xlsx", clear first
 12.                 ds
 13. 
.                 duplicates drop // drop rows of assumptions that are identical
 14.                 count
 15.                 local columns = r(N)
 16.                 ds
 17.                 local varying_assumptions "`r(varlist)'"
 18. 
.                 if inlist("`mode'","baseline", "current")  {
 19.                         confirm var spec_type // check for specification type
>  indicator, previously had a capture
 20.                         if _rc==0 {
 21.                                 keep if spec_type == "`mode'"
 22.                                 assert _N == 1 | _N == 0
 23.                                 if _N == 0{
 24.                                         di in red "Skipping `program' because
>  `mode' does not exist for this program"
 25.                                         continue // skip programs missing cer
> tain assumptions
 26.                                 } 
 27.                 
.                                 qui ds spec_type, not
 28.                                 local varying_assumptions `r(varlist)'
 29.                                 foreach assumption in `r(varlist)'  {
 30.                                         local `assumption'_1 = `assumption'[1
> ]
 31.                                 }
 32.                         }       
 33. 
.                         keep in 1 // where not specified the first row is the ba
> seline specification
 34. 
.                         local correlation_1 = 1
 35.                         local varying_assumptions `varying_assumptions' corre
> lation
 36.                         local columns = _N
 37.                         di `columns'
 38.                 }
 39.                 if "`mode'" != "baseline"{
 40.                         keep if spec_type == "`mode'"
 41.                         ds
 42.                         local varying_assumptions `r(varlist)'
 43.                         foreach assumption in `r(varlist)'{
 44.                                 local `assumption'_1 = `assumption'[1]
 45.                         }
 46.                         local correlation_1 = 1
 47.                         local varying_assumptions `varying_assumptions' corre
> lation
 48.                         local columns = _N
 49.                         di `columns'
 50.                 }
 51. 
.                 local ++m
 52. 
.                 *Loop over types of assumptions
.                 forval c = 1/`columns' {
 53.                         noi di "Specification `c' of `columns', program `m' o
> f `prog_num' (`program')"
 54. 
.                         *set assumptions
.                         foreach assumption in `varying_assumptions' {
 55.                                 global `assumption' ``assumption'_`c''
 56.                         }
 57.                         *generate estimates
.                         clear
 58. 
.                         set obs `replications'
 59. 
.                         di "`program'"
 60.                         * Generate variables to store the estimates and clean
>  globals
.                         local ests MVPF MVPF_no_cc cost WTP program_cost total_c
> ost ///
>                         beh_fisc_ext utility_fisc_ext gas_fisc_ext fed_fisc_ext 
> state_fisc_ext ///
>                         WTP_USPres WTP_USFut WTP_RoW WTP_USTotal enviro_mvpf cos
> t_mvpf firm_mvpf cost_wtp ///
>                         env_cost_wtp marginal infmarg wtp_private wtp_soc wtp_no
> _ice wtp_yes_ev wtp_yes_hev wtp_soc_rbd wtp_yes_ev_local wtp_no_ice_local env_co
> st_wtp_l wtp_soc_rbd_l ///
>                         wtp_yes_ev_g wtp_no_ice_g env_cost_wtp_g wtp_soc_rbd_g /
> //
>                         wtp_marg wtp_inf wtp_glob wtp_loc wtp_r_glob wtp_r_loc w
> tp_e_cost ///
>                         WTP_cc wtp_install wtp_prod wtp_prod_s wtp_prod_u wtp_co
> ns wtp_deal admin_cost ///
>                         wtp_permits wtp_abatement permitrev wtp_no_leak wtp_leak
>  ///
>                         wtp_soc_g wtp_soc_l fisc_ext_t fisc_ext_s fisc_ext_lr q_
> CO2 q_CO2_no p_spend ///
>                         ev_sub_c ev_sub_c_row ev_sub_c_us ev_sub_env ev_sub_cost
>  profits_fisc_e wtp_soc_l_po wtp_soc_l_dr ///
>                         gov_carbon resource_ce q_carbon_mck semie pass_through /
> //
>                         permitrev_new permitrev_ex fiscalext firm_cost_wtp c_sav
> ings resource_cost q_CO2_mck q_CO2_mck_no wtp_ctr gas_corp_fisc_e epsilon /// 
>                         transfer enviro_wtp cost_curve profits subsidies taxes /
> //
>                         wtp_batt wtp_local_w_r wind_g_wf wind_l_wf
 61.                         
.                         foreach est in `ests' {
 62.                                 gen `est'_`program' = .
 63.                                 macro drop `est'_`program'
 64.                         
.                         }
 65.                         cap recast double cost_wtp_`program'
 66.                         cap recast double cost_mvpf_`program'
 67.                         cap recast double MVPF_`program'
 68. 
.                         local i = 1
 69.                         * Simulations: run each do file ~1000 times and store
>  the estimates from each run
.                         if `replications' > 0 {
 70.                                 qui{
 71.                                         forvalues i = 1/`replications' {
 72.                                                 global draw_number = `i'
 73.                                                 di "${program_folder}/`do_fil
> e'"
 74.                                                 * Run the program with the "b
> ootstrap" option and store estimates for this draw
.                                                 if `debug' == 0 qui do "${progra
> m_folder}/`do_file'" `program' yes `use_estimates' `mode' // first place the pol
> icy .do files are called
 75.                                                 if `debug' == 1 noi do "${pro
> gram_folder}/`do_file'" `program' yes `use_estimates' `mode'
 76.                                                 foreach est in `ests'{
 77.                                                         if "${`est'_`program'
> }" != ""{
 78.                                                                 replace `est'
> _`program' = ${`est'_`program'} in `i'                                          
>            
 79.                                                         }
 80.                                                 }
 81.                                         }
 82.                                 }
 83.                         }
 84.                         *** End of 1000 loop
.                                 
.                         * Get point estimates
.                         global draw_number = 0
 85.                         if `debug' == 0 qui do "${program_folder}/`do_file'" 
> `program' no `use_estimates' `mode'
 86.                         if `debug' == 1 noi do "${program_folder}/`do_file'" 
> `program' no `use_estimates' `mode'
 87.                         local inf = 99999
 88.                         local infinity_`program' = `inf'
 89.                                 
.                         
.                         if `replications' >0 {
 90.                                 if inlist("`mode'","baseline", "current")  {
 91.                                         *Save draws
.                                         gen draw_id = _n
 92.                                         local program_temp `program'
 93.                                         local mode_temp `mode'
 94.                                         save "${bootstrap_files}/`program_tem
> p'_`mode_temp'_`replications'_draws_corr_1.dta", replace
 95.                                         drop draw_id
 96.                                 }
 97. 
. 
.                                 * If 99999 is not high enough, set new infinity
.                                 qui su MVPF_`program' if !mi(MVPF_`program')
 98.                                 local max = r(max)
 99.                                 local min = r(min)
100.                                 local infinity_`program' = max(abs(`max'), ab
> s(`min'), `inf' , abs(${MVPF_`program'}))
101.                                 if `infinity_`program''>`inf' {
102.                                         local infinity_`program' = `infinity_
> `program'' * 10
103.                                         replace MVPF_`program' = `infinity_`p
> rogram'' if MVPF_`program' == `inf'
104.                                         replace MVPF_`program' = -`infinity_`
> program'' if MVPF_`program' == -`inf'
105.                                         if ${MVPF_`program'} == `inf' {
106.                                                 global MVPF_`program' = `infi
> nity_`program''
107.                                         }
108.                                         if ${MVPF_`program'} == -`inf' {
109.                                                 global MVPF_`program' = -`inf
> inity_`program''
110.                                         }
111. 
.                                 }
112.                         }
113. 
.                         
.                         *Save all estimates in separate rows
.                         clear
114.                         
.                         local word_count : word count `ests'
115.                         di in red `word_count'
116.                         scalar var_count = `word_count'
117.                         di var_count
118.                         set obs `=scalar(var_count)'
119.                         g col = `c'
120.                         g program = "`program'"
121.                         g component_type = ""
122.                         g component_value = .
123.                         recast double component_value
124.                         g l_component = .
125.                         g u_component = .
126.                         g component_sd = .
127.                         
.                         *********** Making the Final Table of Calculations *****
> ******
.                         local i = 1
128.                         di in red "`i'"
129.                         foreach est in `ests' {
130.                                 di "`est'"
131.                                 replace component_type = "`est'" if _n == `i'
132.                                 if "${`est'_`program'}" != ""{
133.                                         replace component_value = ${`est'_`pr
> ogram'} if _n == `i'
134.                                 }
135.                                 local `est'index = `i'
136.                                 local ++ i
137.                         }
138.                         g infinity = `infinity_`program''
139.                         gen component_over_prog_cost = .
140.                         foreach est in WTP cost {
141.                                 replace component_over_prog_cost = component_
> value / ${program_cost_`program'} if component_type == "`est'"
142.                         }
143. 
.                         *list assumptions
.                         gen assumptions = "`mode'"
144.                         gen correlation = $correlation
145.                         gen replications = $reps
146. 
.                         tempfile `program'_ests_`c'
147.                         save ``program'_ests_`c'', emptyok
148.                         ds
149.                 }
150. 
.                 *---------------------------------------------------------------
> ----------------
.                 *       3. Export estimates
.                 *---------------------------------------------------------------
> ----------------
.                 use ``program'_ests_1', clear
151. 
.                 if `columns' > 1 {
152.                         forval c = 2/`columns' {
153.                                 append using ``program'_ests_`c''
154.                         }
155.                 }
156. 
.                 drop col
157. 
.                 tempfile `program'_unbdd_ests
158.                 save ``program'_unbdd_ests'
159.                 
.                 drop infinity
160.                 tempfile `program'_ests
161.                 save ``program'_ests'
162. 
. 
.                 if "`mode'" == "baseline"{
163.                         local out_temp ${bootstrap_files}
164. 
.                         export delimited using "`out_temp'/`program'_baseline_es
> timates_`replications'_replications.csv", replace
165.                         save "`out_temp'/`program'_baseline_estimates_`replic
> ations'_replications.dta", replace // version used for waterfall charts
166.                         use ``program'_unbdd_ests', clear
167.                         export delimited using "`out_temp'/`program'_baseline
> _unbounded_estimates_`replications'_replications.csv", replace
168.                 }
169.                 else{
170.                         save "${bootstrap_files}/`program'_`mode'_estimates_`
> replications'_replications.dta", replace // version used for waterfall charts
171.                         use ``program'_unbdd_ests', clear
172.                         save "${bootstrap_files}/`program'_`mode'_unbounded_e
> stimates_`replications'_replications.dta", replace
173.                 }
174. 
.                 pause
175. 
.                 di in red "Finished running for `program' under `mode'"
176. 
.                 *Get back bounded estimates for inspection
.                 use ``program'_ests', clear
177. 
. 
.                 if _rc > 0 {
178.                         if _rc == 1 continue, break
179.                         local error_progs = "`error_progs'"+"`program' on `mo
> de', "
180.                         di as err "`program' broke"
181.                 }
182. 
.         } //end of program loop
183. } //end of mode loop
the mode is current
(4 vars, 5 obs)
spec_type    State        policy_year  description

Duplicates in terms of all variables

(0 observations are duplicates)
  5
spec_type    State        policy_year  description
(4 observations deleted)
(0 observations deleted)
1
(0 observations deleted)
spec_type    State        policy_year  description
1
Specification 1 of 1, program 1 of 1 (ct_solar)
Number of observations (_N) was 0, now 0.
ct_solar

. ********************************************************************************
> *****
. /*       0. Program: Connecticut Residential Solar Investment Program          *
> /
. ********************************************************************************
> *****
. 
. /*
> Gillingham, Kenneth, and Tsvetan Tsvetanov. 
> "Hurdles and steps: Estimating demand for solar photovoltaics." 
> Quantitative Economics 10, no. 1 (2019): 275-310.
> *https://onlinelibrary.wiley.com/doi/pdfdirect/10.3982/QE919
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: ct_solar no uncorrected_vJK current

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. local replacement = "${replacement}"

. global spec_type = "`4'"

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow          
. 
. levelsof estimate, local(estimates)
`"elas"' `"farmer_theta"' `"markup"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.651           .      -.651      -.651

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.319           .      -.319      -.319

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .46           .        .46        .46
.         restore
. }

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. 
.         ****************************************************
.         /* 3a. Emissions Factors */
.         ****************************************************
.         if "${spec_type}" == "baseline"{
.                 local dollar_year = ${policy_year}
.         }

.         
.         if "${spec_type}" == "current"{
.                 local dollar_year = ${current_year}
.         }

. 
. 
.         ****************************************************
.         /* 3b. Policy Category Assumptions */
.         ****************************************************
. 
.         *i. Import Solar assumptions
.         preserve

.                 import excel "${policy_assumptions}", first clear sheet("Solar")
(4 vars, 6 obs)

.                 
.                 levelsof Parameter, local(levels)
`"cost_per_watt"' `"farmer_theta"' `"lifetime"' `"marginal_val"' `"output"' `"syst
> em_capacity"'

.                 foreach val of local levels {
  2.                         qui sum Estimate if Parameter == "`val'"
  3.                         global `val' = `r(mean)'
  4.                         local `val' = `r(mean)'
  5.                 }

.                 
.                 local system_capacity = ${system_capacity} // kW

.                 local annual_output = ${output} / (`system_capacity' * 1000) // 
> kWh per year per Watt (kW * 1000)

.                 local lifetime = ${lifetime} 

.                 local marginal_val = ${marginal_val}

.                 local federal_subsidy = 0.26 // percent of cost subsidized, 2020
>  ITC

.                 local cost_per_watt_baseline = ${cost_per_watt} * (${cpi_`dollar
> _year'} / ${cpi_2022}) // expressed in 2022 dollars initially

.         restore

.         
.         if "${subsidy_loop}" == "yes" {
.                 local federal_subsidy = ${fed_sub_loop}
.         }

.         
.         if "${lifetime_change}" == "yes" {
.                 local lifetime = `lifetime' * ${lifetime_scalar}
.         }

. 
.         ****************************************************
.         /* 3c. Policy Specific Assumptions */
.         ****************************************************    
.         
.         ** Own-price elasticity of demand 
.         local e_demand = `elas' // Hurdle model - sum of cols (3) and (4), Table
>  6 

. 
.         ** Cost assumptions
.         local pre_cost_per_watt = ${cost_per_watt} * (${cpi_`dollar_year'} / ${c
> pi_2022})

.         local cost_per_watt = `pre_cost_per_watt' * (1 - `federal_subsidy')

.         local avg_state_rebate = 0 // Assuming no average state rebate.

.         local avg_fed_rebate = `pre_cost_per_watt' * `federal_subsidy'

.         
.         if "${spec_type}" == "baseline" {
.                 local federal_subsidy = 0.3 // Subsidy was 30% in baseline year.
>  https://www.irs.gov/pub/irs-prior/i5695--2014.pdf
.                 local system_capacity =  6.972 // kW, Average system capacity (T
> able 3)
.                 local annual_output =  32.26 / 25 // kWh/Watt, output per unit o
> f installed capacity over 25-year lifespan (pg 302)
.                 
.                 local pre_cost_per_watt = 3.8945 * (${cpi_${policy_year}}/${cpi_
> 2014}) // Table 4 in 2014$
.                 local avg_state_rebate = 3.0427 * (${cpi_${policy_year}}/${cpi_2
> 014}) // Table 4, $/W in 2014$, doesn't include federal subsidy
.                 
.                 local avg_fed_rebate = (`pre_cost_per_watt' + `avg_state_rebate'
> ) * `federal_subsidy' // Assume federal subsidy applies to pre-state-incentive p
> rice. 
.                 
.                 local cost_per_watt = `pre_cost_per_watt' - `avg_fed_rebate'
.         }

.         
. //      if "${spec_type}" == "baseline_gen" {
. //              local federal_subsidy = 0.3
. //              local system_capacity = ${system_capacity}
. //              local annual_output = ${output} / (`system_capacity' * 1000)
. //              local pre_cost_per_watt = 5.40 // https://www.nrel.gov/solar/mar
> ket-research-analysis/solar-installed-system-cost.html
. //              local avg_state_rebate = 0 // US-wide specification
. //              
. //              local cost_per_watt = `pre_cost_per_watt' * (1-`federal_subsidy'
> )
. //              local avg_fed_rebate = `pre_cost_per_watt' * `federal_subsidy'
. //      }
.         
.         local semie = `e_demand'/`cost_per_watt'

. 
. *********************************
. /* 4. Intermediate Calculations */
. *********************************
. 
. * learning by doing
. local cum_sales = (713918 * 1000)/`system_capacity' // 71391800 MW, as of 2020; 
> 176,113.39 MW, as of 2014 (IRENA, 2023)

. local marg_sales = (128050.40 * 1000)/`system_capacity' // 128050.40 MW, in 2020
> ; 39,541.25 MW, in 2014 (IRENA, 2023)

. 
. if `dollar_year' == ${policy_year} {
.         local cum_sales = (176113.39 * 1000)/`system_capacity' //(IRENA, 2023)
.         local marg_sales = (39541.25 * 1000)/`system_capacity' //(IRENA, 2023)
. }

. 
. solar, policy_year(${policy_year}) spec(${spec_type}) semie(`semie') replacement
> (`replacement') p_name("ct_solar") marg_sales(`marg_sales') cum_sales(`cum_sales
> ') annual_output(`annual_output') system_capacity(`system_capacity') pre_cost_pe
> r_watt(`pre_cost_per_watt') avg_state_rebate(`avg_state_rebate') e_demand(`e_dem
> and') pass_through(${solar_passthrough}) farmer_theta(`farmer_theta') federal_su
> bsidy(`federal_subsidy')
(4 vars, 6 obs)
`"cost_per_watt"' `"farmer_theta"' `"lifetime"' `"marginal_val"' `"output"' `"syst
> em_capacity"'
(12 vars, 162 obs)
.78064202
Global Benefits: .5330543950151042
Local Benefits: .0781905400298043
Global Rebound: .1153666266079212
Local Rebound: .0153148704315805
Dynamic Price: 0
Dynamic Enviro: 0
Producer Loss: .0663388796718474
WTP_cc: 10111.70559208495
1.1655261

. 
end of do-file
98
98
Number of observations (_N) was 0, now 98.
(98 missing values generated)
(98 missing values generated)
(98 missing values generated)
(98 missing values generated)
(98 missing values generated)
1
MVPF
variable component_type was str1 now str4
(1 real change made)
(1 real change made)
MVPF_no_cc
variable component_type was str4 now str10
(1 real change made)
cost
(1 real change made)
(1 real change made)
WTP
(1 real change made)
(1 real change made)
program_cost
variable component_type was str10 now str12
(1 real change made)
(1 real change made)
total_cost
(1 real change made)
beh_fisc_ext
(1 real change made)
utility_fisc_ext
variable component_type was str12 now str16
(1 real change made)
gas_fisc_ext
(1 real change made)
fed_fisc_ext
(1 real change made)
state_fisc_ext
(1 real change made)
WTP_USPres
(1 real change made)
(1 real change made)
WTP_USFut
(1 real change made)
(1 real change made)
WTP_RoW
(1 real change made)
(1 real change made)
WTP_USTotal
(1 real change made)
enviro_mvpf
(1 real change made)
(1 real change made)
cost_mvpf
(1 real change made)
(1 real change made)
firm_mvpf
(1 real change made)
(1 real change made)
cost_wtp
(1 real change made)
(1 real change made)
env_cost_wtp
(1 real change made)
(1 real change made)
marginal
(1 real change made)
infmarg
(1 real change made)
wtp_private
(1 real change made)
(1 real change made)
wtp_soc
(1 real change made)
(1 real change made)
wtp_no_ice
(1 real change made)
wtp_yes_ev
(1 real change made)
wtp_yes_hev
(1 real change made)
wtp_soc_rbd
(1 real change made)
wtp_yes_ev_local
(1 real change made)
wtp_no_ice_local
(1 real change made)
env_cost_wtp_l
(1 real change made)
(1 real change made)
wtp_soc_rbd_l
(1 real change made)
wtp_yes_ev_g
(1 real change made)
wtp_no_ice_g
(1 real change made)
env_cost_wtp_g
(1 real change made)
(1 real change made)
wtp_soc_rbd_g
(1 real change made)
wtp_marg
(1 real change made)
wtp_inf
(1 real change made)
wtp_glob
(1 real change made)
(1 real change made)
wtp_loc
(1 real change made)
(1 real change made)
wtp_r_glob
(1 real change made)
(1 real change made)
wtp_r_loc
(1 real change made)
(1 real change made)
wtp_e_cost
(1 real change made)
(1 real change made)
WTP_cc
(1 real change made)
(1 real change made)
wtp_install
(1 real change made)
(1 real change made)
wtp_prod
(1 real change made)
(1 real change made)
wtp_prod_s
(1 real change made)
wtp_prod_u
(1 real change made)
wtp_cons
(1 real change made)
(1 real change made)
wtp_deal
(1 real change made)
admin_cost
(1 real change made)
wtp_permits
(1 real change made)
wtp_abatement
(1 real change made)
permitrev
(1 real change made)
wtp_no_leak
(1 real change made)
wtp_leak
(1 real change made)
wtp_soc_g
(1 real change made)
wtp_soc_l
(1 real change made)
fisc_ext_t
(1 real change made)
(1 real change made)
fisc_ext_s
(1 real change made)
(1 real change made)
fisc_ext_lr
(1 real change made)
(1 real change made)
q_CO2
(1 real change made)
(1 real change made)
q_CO2_no
(1 real change made)
p_spend
(1 real change made)
(1 real change made)
ev_sub_c
(1 real change made)
ev_sub_c_row
(1 real change made)
ev_sub_c_us
(1 real change made)
ev_sub_env
(1 real change made)
ev_sub_cost
(1 real change made)
profits_fisc_e
(1 real change made)
wtp_soc_l_po
(1 real change made)
wtp_soc_l_dr
(1 real change made)
gov_carbon
(1 real change made)
(1 real change made)
resource_ce
(1 real change made)
(1 real change made)
q_carbon_mck
(1 real change made)
(1 real change made)
semie
(1 real change made)
(1 real change made)
pass_through
(1 real change made)
(1 real change made)
permitrev_new
(1 real change made)
permitrev_ex
(1 real change made)
fiscalext
(1 real change made)
firm_cost_wtp
(1 real change made)
(1 real change made)
c_savings
(1 real change made)
(1 real change made)
resource_cost
(1 real change made)
(1 real change made)
q_CO2_mck
(1 real change made)
(1 real change made)
q_CO2_mck_no
(1 real change made)
wtp_ctr
(1 real change made)
gas_corp_fisc_e
(1 real change made)
epsilon
(1 real change made)
transfer
(1 real change made)
enviro_wtp
(1 real change made)
cost_curve
(1 real change made)
profits
(1 real change made)
subsidies
(1 real change made)
taxes
(1 real change made)
wtp_batt
(1 real change made)
wtp_local_w_r
(1 real change made)
wind_g_wf
(1 real change made)
wind_l_wf
(1 real change made)
(98 missing values generated)
(1 real change made)
(1 real change made)
file C:\Users\sethuo\AppData\Local\Temp\ST_8db4_000002.tmp saved as .dta format
col           component~ue  component_sd  assumptions
program       l_component   infinity      correlation
component~pe  u_component   component_~t  replications
file C:\Users\sethuo\AppData\Local\Temp\ST_8db4_000003.tmp saved as .dta format
file C:\Users\sethuo\AppData\Local\Temp\ST_8db4_000004.tmp saved as .dta format
(file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/3_bootstrap_draws/2025-07
    > -28_21-01-53__full_current_no_lbd_uncorrected_vJK/ct_solar_current_estimat
    > es_0_replications.dta not found)
file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/3_bootstrap_draws/2025-07
    > -28_21-01-53__full_current_no_lbd_uncorrected_vJK/ct_solar_current_estimat
    > es_0_replications.dta saved
(file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/3_bootstrap_draws/2025-07
    > -28_21-01-53__full_current_no_lbd_uncorrected_vJK/ct_solar_current_unbound
    > ed_estimates_0_replications.dta not found)
file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/3_bootstrap_draws/2025-07
    > -28_21-01-53__full_current_no_lbd_uncorrected_vJK/ct_solar_current_unbound
    > ed_estimates_0_replications.dta saved
Finished running for ct_solar under current
ct_solar broke

.  
. 
. *Throw errors if things didn't run
. if _rc != 1 {
.         global error_progs = "`error_progs'"
.         if "`error_progs'" != "" di as err "Finished running but the following p
> rograms threw errors: `error_progs'"
Finished running but the following programs threw errors: ct_solar on current, 
.         else di in red "Finished running with no errors"
. }

. 
. 
. 
end of do-file
SECTION 3: COMPILE ESTIMATES & INFERENCE
compile programs is ct_solar
compile loop modes is current
current
(file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/4_results/2025-07-28_21-0
    > 1-53__full_current_no_lbd/compiled_results_all_uncorrected_vJK.dta not
    found)
file
    C:/Users/sethuo/Documents/GitHub/mvpf-climate/data/4_results/2025-07-28_21-0
    > 1-53__full_current_no_lbd/compiled_results_all_uncorrected_vJK.dta saved

. 
. noi di "== END OF SCRIPT =="
== END OF SCRIPT ==

. beep

. 
. 
end of do-file
. }

. 
. *---------------
. * 4 - Robustness
. *---------------
. 
. do "${github}/wrapper/robustness.do"

. /*-----------------------------------------------------------------------
> * Run Calculations for Different Specifications
> *-----------------------------------------------------------------------*/
. 
. tempname numbers

. tempfile robustness_values

. postfile `numbers' str80 label value using `robustness_values', replace
(file C:\Users\sethuo\AppData\Local\Temp\ST_8db4_000002.tmp not found)

. 
. local pattern_suffix = "full_current_193"

. di in yellow "Looking for folders ending with pattern: `pattern_suffix'"
Looking for folders ending with pattern: full_current_193

. 
. * Find all folders in the results directory that end with the pattern
. local results_dir = "${code_files}/4_results"

. local folder_list = ""

. local folder_dates = ""

. 
. * Get list of all subdirectories
. qui local folders : dir "`results_dir'" dirs "*"

. 
. * Filter folders that end with our pattern and extract timestamps
. foreach folder of local folders {
  2.             di in red "Checking: `folder' against pattern: __`pattern_suffix'
> $"
  3.     if regexm("`folder'", "^([0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}-[0-
> 9]{2})__`pattern_suffix'$") {
  4.         local timestamp = regexs(1)
  5.         local folder_list = "`folder_list' `folder'"
  6.         local folder_dates = "`folder_dates' `timestamp'"
  7.         di in green "Found matching folder: `folder' (timestamp: `timestamp')
> "
  8.     }
  9. }
Checking: 2024-11-04_16-42-05__corrected_ests_for_mvpf_plot against pattern: __ful
> l_current_193$
Checking: 2024-11-15_01-14-07__full_incontext_193_nov against pattern: __full_curr
> ent_193$
Checking: 2024-11-15_01-31-00__full_current_no_lbd_193 against pattern: __full_cur
> rent_193$
Checking: 2024-11-15_01-32-09__full_current_savings_193 against pattern: __full_cu
> rrent_193$
Checking: 2024-11-15_02-01-52__full_current_noprofits_193 against pattern: __full_
> current_193$
Checking: 2024-11-15_09-44-45__full_current_193 against pattern: __full_current_19
> 3$
Found matching folder: 2024-11-15_09-44-45__full_current_193 (timestamp: 2024-11-1
> 5_09-44-45)
Checking: 2024-11-15_09-44-45__full_current_193_nov against pattern: __full_curren
> t_193$
Checking: 2024-11-16_14-43-50__full_current_76 against pattern: __full_current_193
> $
Checking: 2024-11-16_14-43-50__full_current_76_nov against pattern: __full_current
> _193$
Checking: 2024-11-16_15-20-07__full_current_337 against pattern: __full_current_19
> 3$
Checking: 2025-04-30_14-15-18__full_current_193_mi_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-05-08_11-59-51__full_current_1367 against pattern: __full_current_1
> 93$
Checking: 2025-05-08_16-06-17__full_current_1367 against pattern: __full_current_1
> 93$
Checking: 2025-05-12_10-00-24__full_current_no_lbd_337 against pattern: __full_cur
> rent_193$
Checking: 2025-05-12_10-16-37__full_current_no_lbd_76 against pattern: __full_curr
> ent_193$
Checking: 2025-05-12_11-02-47__full_current_noprofits_337 against pattern: __full_
> current_193$
Checking: 2025-05-12_14-55-09__full_current_noprofits_76 against pattern: __full_c
> urrent_193$
Checking: 2025-05-13_10-30-42__full_current_193_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-05-13_15-32-51__full_current_193_2_rb against pattern: __full_curre
> nt_193$
Checking: 2025-05-13_17-00-23__full_current_337_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-05-13_17-43-31__full_current_337_2_rb against pattern: __full_curre
> nt_193$
Checking: 2025-05-13_19-40-13__full_current_76_zero_rb against pattern: __full_cur
> rent_193$
Checking: 2025-05-13_22-11-19__full_current_76_2_rb against pattern: __full_curren
> t_193$
Checking: 2025-05-13_23-48-41__full_current_76_mi_grid against pattern: __full_cur
> rent_193$
Checking: 2025-05-14_00-32-09__full_current_337_mi_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-05-14_01-15-05__full_current_76_ca_grid against pattern: __full_cur
> rent_193$
Checking: 2025-05-14_01-58-31__full_current_337_ca_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-05-14_10-08-21__full_current_savings_337 against pattern: __full_cu
> rrent_193$
Checking: 2025-05-14_11-16-30__full_current_savings_76 against pattern: __full_cur
> rent_193$
Checking: 2025-05-14_16-50-20__full_current_193_clean_grid against pattern: __full
> _current_193$
Checking: 2025-05-15_13-12-13__full_current_193_evs_clean_grid against pattern: __
> full_current_193$
Checking: 2025-05-22_15-06-30__ev_vmt_rebound_one_193 against pattern: __full_curr
> ent_193$
Checking: 2025-05-26_23-04-43__ev_vehicle_lifetime_15 against pattern: __full_curr
> ent_193$
Checking: 2025-05-27_09-46-39__ev_vehicle_lifetime_15 against pattern: __full_curr
> ent_193$
Checking: 2025-05-27_09-47-02__ev_vehicle_lifetime_15 against pattern: __full_curr
> ent_193$
Checking: 2025-05-27_09-55-29__ev_vehicle_lifetime_20 against pattern: __full_curr
> ent_193$
Checking: 2025-05-27_10-34-23__ev_vehicle_lifetime_20 against pattern: __full_curr
> ent_193$
Checking: 2025-05-27_10-50-23__ev_new_car_193 against pattern: __full_current_193$
Checking: 2025-05-27_13-48-55__ev_new_car_193 against pattern: __full_current_193$
Checking: 2025-05-27_14-08-01__ev_new_car_193 against pattern: __full_current_193$
Checking: 2025-05-30_09-45-13__full_current_193 against pattern: __full_current_19
> 3$
Found matching folder: 2025-05-30_09-45-13__full_current_193 (timestamp: 2025-05-3
> 0_09-45-13)
Checking: 2025-06-17_19-57-52__testing against pattern: __full_current_193$
Checking: 2025-06-17_20-05-48__testing against pattern: __full_current_193$
Checking: 2025-06-17_20-07-16__testing against pattern: __full_current_193$
Checking: 2025-06-17_20-10-01__testing against pattern: __full_current_193$
Checking: 2025-06-17_20-15-58__testing against pattern: __full_current_193$
Checking: 2025-06-18_10-08-26__testing against pattern: __full_current_193$
Checking: 2025-06-18_14-26-30__testing against pattern: __full_current_193$
Checking: 2025-06-19_22-11-30__testing_all against pattern: __full_current_193$
Checking: 2025-06-20_10-23-46__testing_all_more against pattern: __full_current_19
> 3$
Checking: 2025-06-23_23-45-47__full_current_193 against pattern: __full_current_19
> 3$
Found matching folder: 2025-06-23_23-45-47__full_current_193 (timestamp: 2025-06-2
> 3_23-45-47)
Checking: 2025-06-24_00-26-10__full_current_76 against pattern: __full_current_193
> $
Checking: 2025-06-24_00-58-49__full_current_337 against pattern: __full_current_19
> 3$
Checking: 2025-06-24_01-31-08__full_incontext against pattern: __full_current_193$
Checking: 2025-06-24_09-39-13__full_incontext against pattern: __full_current_193$
Checking: 2025-06-24_10-01-36__full_incontext against pattern: __full_current_193$
Checking: 2025-06-24_10-16-12__full_incontext against pattern: __full_current_193$
Checking: 2025-06-24_10-16-18__full_incontext against pattern: __full_current_193$
Checking: 2025-06-24_10-54-44__full_current_no_lbd against pattern: __full_current
> _193$
Checking: 2025-06-24_10-59-06__macro_define against pattern: __full_current_193$
Checking: 2025-06-24_11-00-34__full_current_savings against pattern: __full_curren
> t_193$
Checking: 2025-06-24_14-15-45__full_current_193_ca_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-06-24_15-02-15__full_current_193_mi_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-06-24_21-38-48__no_lbd_bootstraps against pattern: __full_current_1
> 93$
Checking: 2025-06-25_00-36-37__no_lbd_bootstraps against pattern: __full_current_1
> 93$
Checking: 2025-06-25_10-21-29__full_current_no_lbd_193 against pattern: __full_cur
> rent_193$
Checking: 2025-06-25_11-26-09__full_current_193_pub_bias_and_lbd against pattern: 
> __full_current_193$
Checking: 2025-06-25_11-38-06__testing against pattern: __full_current_193$
Checking: 2025-06-25_11-40-07__testing against pattern: __full_current_193$
Checking: 2025-06-25_11-40-13__testing against pattern: __full_current_193$
Checking: 2025-06-25_12-49-16__full_current_193_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-06-25_13-02-41__full_current_193_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-06-25_13-03-48__full_current_193_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-06-25_14-19-48__full_current_193_2_rb against pattern: __full_curre
> nt_193$
Checking: 2025-06-25_23-58-36__full_current_193_pub_bias_and_lbd against pattern: 
> __full_current_193$
Checking: 2025-06-26_07-52-07__full_current_no_lbd_193 against pattern: __full_cur
> rent_193$
Checking: 2025-06-26_08-02-40__full_current_noprofits_193 against pattern: __full_
> current_193$
Checking: 2025-06-26_08-33-43__full_current_savings_193 against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_09-55-37__full_current_193_ca_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_10-18-17__full_current_193_mi_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_10-35-35__full_current_193_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_10-57-15__full_current_193_2_rb against pattern: __full_curre
> nt_193$
Checking: 2025-06-26_11-17-34__full_current_no_lbd_76 against pattern: __full_curr
> ent_193$
Checking: 2025-06-26_11-27-56__full_current_noprofits_76 against pattern: __full_c
> urrent_193$
Checking: 2025-06-26_11-49-26__full_current_savings_76 against pattern: __full_cur
> rent_193$
Checking: 2025-06-26_12-07-25__full_current_76_ca_grid against pattern: __full_cur
> rent_193$
Checking: 2025-06-26_12-29-23__full_current_76_mi_grid against pattern: __full_cur
> rent_193$
Checking: 2025-06-26_13-08-16__full_current_76_zero_rb against pattern: __full_cur
> rent_193$
Checking: 2025-06-26_13-44-26__full_current_76_2_rb against pattern: __full_curren
> t_193$
Checking: 2025-06-26_14-20-21__full_current_no_lbd_337 against pattern: __full_cur
> rent_193$
Checking: 2025-06-26_14-35-38__full_current_noprofits_337 against pattern: __full_
> current_193$
Checking: 2025-06-26_15-53-13__full_current_savings_337 against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_16-29-11__full_current_337_ca_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_17-05-25__full_current_337_mi_grid against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_17-31-23__full_current_337_zero_rb against pattern: __full_cu
> rrent_193$
Checking: 2025-06-26_17-53-36__full_current_337_2_rb against pattern: __full_curre
> nt_193$
Checking: 2025-06-27_11-09-49__full_current_193 against pattern: __full_current_19
> 3$
Found matching folder: 2025-06-27_11-09-49__full_current_193 (timestamp: 2025-06-2
> 7_11-09-49)
Checking: 2025-06-27_11-36-52__full_current_76 against pattern: __full_current_193
> $
Checking: 2025-06-27_11-59-16__full_current_337 against pattern: __full_current_19
> 3$
Checking: 2025-07-28_20-08-36__full_current_193 against pattern: __full_current_19
> 3$
Found matching folder: 2025-07-28_20-08-36__full_current_193 (timestamp: 2025-07-2
> 8_20-08-36)
Checking: 2025-07-28_21-01-53__full_current_no_lbd against pattern: __full_current
> _193$
Checking: ev_grid against pattern: __full_current_193$
Checking: ev_no_lbd_grid against pattern: __full_current_193$
Checking: local_assumption_mvpf_plot_data against pattern: __full_current_193$
Checking: no_lbd_grid against pattern: __full_current_193$
Checking: solar_grid against pattern: __full_current_193$
Checking: wind_grid against pattern: __full_current_193$

. 
. * If no matching folders found, display error and exit
. if "`folder_list'" == "" {
.     di as error "`pattern_suffix' folder has not been created, please run the ma
> sterfile first to create this folder"
.     exit 601
. }

. else {
.     * Find the most recent folder by comparing timestamps
.     local most_recent_folder = ""
.     local most_recent_timestamp = ""
.     
.     local folder_count : word count `folder_list'
.     local date_count : word count `folder_dates'
.     
.     forvalues i = 1/`folder_count' {
  2.         local current_folder : word `i' of `folder_list'
  3.         local current_timestamp : word `i' of `folder_dates'
  4.         
.         * Convert timestamp to comparable format (remove hyphens and underscores
> )
.         local current_numeric = subinstr(subinstr("`current_timestamp'", "-", ""
> , .), "_", "", .)
  5.         
.         if "`most_recent_timestamp'" == "" {
  6.             local most_recent_folder = "`current_folder'"
  7.             local most_recent_timestamp = "`current_numeric'"
  8.         }
  9.         else {
 10.             local most_recent_numeric = subinstr(subinstr("`most_recent_times
> tamp'", "-", "", .), "_", "", .)
 11.             if `current_numeric' > `most_recent_numeric' {
 12.                 local most_recent_folder = "`current_folder'"
 13.                 local most_recent_timestamp = "`current_numeric'"
 14.             }
 15.         }
 16.     }
.     
.     local main_data_set = "`most_recent_folder'"
.     di in green "Selected most recent folder: `main_data_set'"
Selected most recent folder: 2025-07-28_20-08-36__full_current_193
. }

. 
. 
. * local main_data_set = "2024-11-15_09-44-45__full_current_193_nov"
. global lbd "yes"

. 
. *----------------------
. * 1 - Electric Vehicles
. *----------------------
. 
. run_program muehl_efmp
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file

. post `numbers' ("muehl_efmp_no_ice_local") (${wtp_no_ice_local_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_no_ice") (${wtp_no_ice_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_yes_ev_local") (${wtp_yes_ev_local_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_wtp_yes_ev") (${wtp_yes_ev_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_rbd_glob") (${wtp_soc_rbd_g_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_rbd_loc") (${wtp_soc_rbd_l_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_batt_damages") (${batt_damages_muehl_efmp})

. 
. post `numbers' ("muehl_efmp_wtp_batt") (${wtp_batt_muehl_efmp})

. 
. post `numbers' ("gas_markup_percent") (${nominal_gas_markup_2020} / ${nominal_ga
> s_price_2020})

. 
. run_program muehl_efmp, ev_fed_subsidy(7500)
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file

. 
. post `numbers' ("muehl_efmp_fe_7500") (${total_cost_muehl_efmp} - ${program_cost
> _muehl_efmp})

. 
. post `numbers' ("muehl_efmp_mvpf_7500") (${MVPF_muehl_efmp})

. 
. run_program muehl_efmp, ev_fed_subsidy(0)
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file

. 
. post `numbers' ("muehl_efmp_mvpf_0") (${MVPF_muehl_efmp}) 

. 
. tempname ev_non_marg

. tempfile ev_non_marginal_mvpf

. postfile `ev_non_marg' subsidy mvpf using `ev_non_marginal_mvpf' 

. 
. forvalues s = 0(50)10000{
  2. 
.     run_program muehl_efmp, ev_fed_subsidy(`s')
  3.     post `ev_non_marg' (`s') (${MVPF_muehl_efmp})
  4. 
. }
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)'
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
. 
.         if `marg_mvpf' == 1{
.                 local dyn_price = `r(cost_mvpf)'
.                 local cost_wtp = `r(cost_mvpf)' * `program_cost' * 0.85 // pass-
> through
.                 local env_cost_wtp = (`dyn_enviro_local' + `dyn_enviro_global') 
> * `program_cost' * 0.85 // pass-through
.                 local env_cost_wtp_l = `dyn_enviro_local' * `program_cost' * 0.8
> 5
.                 local env_cost_wtp_global_tot = `dyn_enviro_global_tot' * `progr
> am_cost' * 0.85
.                 local env_cost_wtp_g = `dyn_enviro_global' * `program_cost' * 0.
> 85
.         }
.         else if `non_marg_mvpf' == 1{
.                 local cost_wtp = (`r(cost_mvpf)' * `program_cost') / (1 + `beh_r
> esponse')
.                 local env_cost_wtp = (`r(enviro_mvpf)' * `program_cost') / (1 + 
> `beh_response')
.         }
. }

. 
. local q_carbon = `q_carbon_no_ice' + `q_carbon_yes_ev' + `q_carbon_rbd'

. local q_carbon_no = `q_carbon'

. local q_carbon_cost_curve = `dyn_enviro_global_tot' / ${sc_CO2_`dollar_year'}

. local q_carbon_cost_curve_mck = `q_carbon_cost_curve' / `beh_response'

. local q_carbon_mck = `q_carbon_no_ice_mck' + `q_carbon_yes_ev_mck' + `q_carbon_r
> bd_mck'

. local q_carbon = `q_carbon' + `q_carbon_cost_curve'

. 
. 
. ********** Long-Run Fiscal Externality **********
. 
. local fisc_ext_lr = -1 * (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot' + `w
> tp_soc_rbd_global_tot' + `env_cost_wtp_global_tot' + `batt_man_ext_tot') * ${USS
> hareFutureSSC} * ${USShareGovtFutureSCC}

. local total_cost = `total_cost' + `fisc_ext_lr' + `gas_corp_fisc_e'

. 
. ************************************************
. 
. if "${value_savings}" == "yes" & "`4'" == "current" {
.         
.         local wtp_savings = `beh_response' * (${`bev_cf'_cf_gas_savings_`dollar_
> year'} - ${yes_ev_savings_`dollar_year'}) 
.         
. }

. else {
.         
.         local wtp_savings = 0
.         
. }

. 
. * Total WTP
. local WTP = `wtp_private' + `wtp_soc' + `wtp_soc_rbd' + `wtp_savings' // not inc
> luding learning-by-doing

. local WTP_cc = `WTP' + `cost_wtp' + `env_cost_wtp'

. 
. // Quick Decomposition
. 
. /* Assumptions:
> 
>         - wtp_private, cost_wtp -> US Present
>         - wtp_soc, env_cost_wtp -> US Future & Rest of the World
> 
> */
. 
. local WTP_USPres = `wtp_private' + `wtp_yes_ev_local' + `wtp_no_ice_local' + `en
> v_cost_wtp_l' + `wtp_soc_rbd_l'

. local WTP_USFut = (${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC})) * (`wtp_
> yes_ev_global_tot' + `wtp_no_ice_global_tot' + `env_cost_wtp_global_tot' + `wtp_
> soc_rbd_global_tot') + 0.1 * `cost_wtp'

. local WTP_RoW = (1 - ${USShareFutureSSC}) * (`wtp_yes_ev_global_tot' + `wtp_no_i
> ce_global_tot' + `env_cost_wtp_global_tot' + `wtp_soc_rbd_global_tot') + 0.9 * `
> cost_wtp'

. 
. **************************
. /* 8. MVPF Calculations */
. **************************
. 
. local MVPF = `WTP_cc' / `total_cost'

. local MVPF_no_cc = `WTP' / `total_cost'

. 
. ****************************************
. /* 9. Cost-Effectiveness Calculations */
. ****************************************
. local avg_lcoe = ${energy_cost}

. local energy_cost = `avg_lcoe'

. 
. local lifetime_energy_cost = 0

. forvalues y = 1(1)`ub'{
  2.         local lifetime_energy_cost = `lifetime_energy_cost' + (`ev_miles_trav
> eled`y'' * `kwh_per_mile' * `energy_cost') / ((1 + `discount')^(`y' - 1))
  3. }

. 
. 
. 
. local purchase_price_diff = 8166 * (${cpi_2020} / ${cpi_2023}) // from vin diese
> l

. 
. local lifetime_gas_cost = ${clean_car_cf_gas_savings_2020} - ${clean_car_wtp_pro
> d_s_2020} - 0.08 * ${clean_car_cf_gas_savings_2020} - ${clean_car_cf_gas_fisc_ex
> t_2020}

. 
. local resource_cost = `purchase_price_diff' + `lifetime_energy_cost' - `lifetime
> _gas_cost'

. di in red "resource cost is `resource_cost'"
resource cost is 6634.205863763369

. 
. local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_2020} - (59.5 * `batt_cap' 
> * 0.001) - ${yes_ev_rbd_CO2_2020} // need to remove the rebound effect, 59.5 fro
> m Winjobi et al. (2022)

. 
. local q_carbon_no_ice_mck = ${clean_car_cf_carbon_2020}

. 
. local q_carbon_mck = `q_carbon_yes_ev_mck' + `q_carbon_no_ice_mck'

. 
. local resource_ce = `resource_cost' / `q_carbon_mck'

. 
. local gov_carbon = `semie' * `q_carbon_mck' + (1 - `rbd_coeff') * `semie' * `q_c
> arbon_mck'

. 
. *****************
. /* 10. Outputs */
. *****************
. 
. global MVPF_`1' = `MVPF'

. global MVPF_no_cc_`1' = `MVPF_no_cc'

. global cost_`1' = `total_cost'

. global WTP_`1' = `WTP'

. global WTP_cc_`1' = `WTP_cc'

. global enviro_mvpf_`1' = `dyn_enviro_global_tot'

. global cost_mvpf_`1' = `dyn_price'

. global wtp_marg_`1' = `wtp_marg'

. global wtp_inf_`1' = `wtp_inf'

. global wtp_cons_`1' = `wtp_cons'

. global wtp_deal_`1' = `wtp_deal'

. global wtp_prod_s_`1' = -`wtp_prod_s'

. global wtp_prod_u_`1' = `wtp_prod_u'

. 
. global program_cost_`1' = `program_cost'

. global total_cost_`1' = `total_cost'

. global utility_fisc_ext_`1' = -`utility_fisc_ext'

. global gas_fisc_ext_`1' = `gas_fisc_ext'

. global beh_fisc_ext_`1' = `beh_fisc_ext'

. global state_fisc_ext_`1' = 0

. global fed_fisc_ext_`1' = `fed_fisc_ext'

. global fisc_ext_lr_`1' = `fisc_ext_lr'

. global gas_corp_fisc_e_`1' = `gas_corp_fisc_e'

. global `1'_`4'_ep = round(`epsilon', 0.001)

. 
. global profits_fisc_e_`1' = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_soc_`1' = `wtp_soc'

. global wtp_glob_`1' = `wtp_glob' 

. global wtp_loc_`1'= `wtp_loc'

. 
. global wtp_no_ice_`1' = `wtp_no_ice'

. global wtp_no_ice_local_`1' = `wtp_no_ice_local'

. global wtp_no_ice_g_`1' = `wtp_no_ice_g'

. 
. global wtp_yes_ev_`1' = `wtp_yes_ev'

. global wtp_yes_ev_local_`1' = `wtp_yes_ev_local'

. global wtp_yes_ev_g_`1' = `wtp_yes_ev_g'

.         
. global wtp_soc_rbd_`1' = `wtp_soc_rbd'

. global wtp_soc_rbd_l_`1' = `wtp_soc_rbd_l'

. global wtp_soc_rbd_g_`1' = `wtp_soc_rbd_g'

. 
. global env_cost_wtp_`1' = `env_cost_wtp'

. global env_cost_wtp_l_`1' = `env_cost_wtp_l'

. global env_cost_wtp_g_`1' = `env_cost_wtp_g'

. 
. global cost_wtp_`1' = `cost_wtp'

. 
. global WTP_USPres_`1' = `WTP_USPres'

. global WTP_USFut_`1'  = `WTP_USFut'

. global WTP_RoW_`1'    = `WTP_RoW'

. 
. global c_savings_`1' = `wtp_savings'

. 
. global gov_carbon_`1' = `gov_carbon'

. global q_CO2_`1' = `gov_carbon'

. global resource_ce_`1' = `resource_ce'

. global q_carbon_mck_`1' = `q_carbon_mck'

. global semie_`1' = `semie'

. global pass_through_`1' = `pass_through'

. 
. global transfer_`1' = `wtp_cons' + `wtp_deal'

. global enviro_wtp_`1' = `wtp_glob' + `wtp_loc' + `wtp_soc_rbd'

. global cost_curve_`1' = `env_cost_wtp' + `cost_wtp'

. global profits_`1' = `wtp_prod_u' + -`wtp_prod_s'

. global subsidies_`1' = `beh_fisc_ext' + `fed_fisc_ext'

. global taxes_`1' = `gas_fisc_ext' + `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. global wtp_ev_g_w_r_`1' = ${wtp_yes_ev_g_`1'} + ${wtp_soc_rbd_g_`1'} // ((${yes_
> ev_damages_global_no_r_`dollar_year'} * (1 - (${USShareFutureSSC} * ${USShareGov
> tFutureSCC})))) * `beh_response' * -1

. 
. global wtp_local_w_r_`1' = (${wtp_loc_`1'} + `wtp_soc_rbd_l') // (${`bev_cf'_cf_
> damages_loc_`dollar_year'} - ${yes_ev_damages_local_`dollar_year'}) * `beh_respo
> nse'

. global wtp_batt_`1' = -`batt_man_ext'

. 
. global batt_damages_`1' = `batt_damages'

. global batt_damages_n_`1' = `batt_damages_n'

. 
. 
. ** for waterfall charts
. 
. if `simplified_wf' == 1{
.         global wtp_comps_`1' transfer enviro_wtp cost_curve profits WTP_cc
.         global wtp_comps_`1'_commas "transfer", "enviro_wtp", "cost_curve", "pro
> fits", "WTP_cc"
. 
.         global cost_comps_`1' program_cost subsidies taxes fisc_ext_lr total_cos
> t
.         global cost_comps_`1'_commas "program_cost", "subsidies", "taxes", "fisc
> _ext_lr", "total_cost"
. 
.         global `1'_xlab 1 `"Transfer"' 2 `"Environment"' 3 `"Learning-by-Doing"'
>  4 `"Profits"' 5 `"Total WTP"' 7 `""Program" "Cost""' 8 `"Subsidies"' 9 `"Taxes"
> ' 10 `""Climate" "FE""' 11 `""Govt" "Cost""' ///
> 
.         *color groupings
.         global color_group1_`1' = 1
.         global color_group2_`1' = 2
.         global color_group3_`1' = 3
.         global color_group4_`1' = 4
.         global cost_color_start_`1' = 7
.         global color_group5_`1' = 10
. }

. 
. if `marg_mvpf' == 1 & `want_rebound' == 1 & `simplified_wf' == 0{
.         
.         global wtp_comps_`1' wtp_cons wtp_deal wtp_no_ice_g wtp_yes_ev_g wtp_soc
> _rbd_g wtp_batt wtp_local_w_r env_cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
.         
.         global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_no_ice_g", "wtp
> _yes_ev_g", "wtp_soc_rbd_g", "wtp_batt", "wtp_local_w_r", "env_cost_wtp", "cost_
> wtp"    
.         global wtp_comps_`1'_commas2 "wtp_prod_s", "wtp_prod_u", "WTP_cc"
.         
.         global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
.         global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. 
. 
. 
.         global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 "Gasoline" 4 "Grid" 5 "R
> ebound" 6 "Batteries" ///
>                                         7 `""Env" "Local""' 8 `""Dynamic" "Env."
> "' 9 `""Dynamic" "Price""' 10 `""Gasoline" "Producers""' 11 `"Utilities"' ///
>                                         12 `""Total" "WTP""' 14 `""Program" "Cos
> t""' 15 `""State" "Subsidy""' 16 `""Federal" "Subsidy""' ///
>                                         17 `""Gas" "Tax""' 18 `""Profits" "Tax""
> ' 19 `""Climate" "FE""' 20 `""Govt" "Cost""' 
. 
.         *color groupings
.         global color_group1_`1' = 2
.         global color_group2_`1' = 7
.         global color_group3_`1' = 9
.         global color_group4_`1' = 11
.         global cost_color_start_`1' = 14
.         global color_group5_`1' = 19
.         
.         
. //      global wtp_comps_`1' wtp_cons wtp_deal wtp_glob wtp_loc wtp_soc_rbd env_
> cost_wtp cost_wtp wtp_prod_s wtp_prod_u WTP_cc
. //      global wtp_comps_`1'_commas "wtp_cons", "wtp_deal", "wtp_glob", "wtp_loc
> ", "wtp_soc_rbd", "env_cost_wtp", "wtp_prod_s", "wtp_prod_u"
. //      global wtp_comps_`1'_commas2 "cost_wtp", "WTP_cc"
. //
. //      global cost_comps_`1' program_cost beh_fisc_ext fed_fisc_ext gas_fisc_ex
> t profits_fisc_e fisc_ext_lr total_cost
. //      global cost_comps_`1'_commas "program_cost", "beh_fisc_ext", "fed_fisc_e
> xt", "gas_fisc_ext", "profits_fisc_e", "fisc_ext_lr", "total_cost"
. //
. //      global `1'_xlab 1 `"Consumers"' 2 `"Dealers"' 3 `""Global" "Env.""' 4 `"
> "Local" "Env.""' 5 `"Rebound"' 6 `""Dynamic" "Env.""' 7 `""Dynamic" "Price""' 8 
> `""Gasoline" "Producers""' 9 `"Utilities"' 10 `"Total WTP"' 12 `""Program" "Cost
> ""' 13 `""State" "Subsidy""' 14 `""Federal" "Subsidy""' 15 `""Gas" "Tax""' 16 `"
> "Profits" "Tax""' 17 `""Climate" "FE""' 18 `""Govt" "Cost""' ///
. //
. //      *color groupings
. //      global color_group1_`1' = 2
. //      global color_group2_`1' = 5
. //      global color_group3_`1' = 7
. //      global color_group4_`1' = 9
. //      global cost_color_start_`1' = 12
. //      global color_group5_`1' = 17
. }

. 
. 
. global `1'_name "California Enhanced Fleet Modernization Program"

. 
. 
. 
. // Stuff for the description
. if `marg_mvpf' == 1{
.         local mvpf_def "Marginal"
.         if `s_0' == 1{
.                 local s_def "s_0"
.         }
.         if `s_1' == 1{
.                 local s_def "s_1"
.         }
.         if `s_bar' == 1{
.                 local s_def "s_bar"
.         }
. }

. if `non_marg_mvpf' == 1{
.         local mvpf_def "Non-Marginal"
.         local s_def "N/A"
. }

. if `new_cost_curve' == 1{
.         local cc_def "Dynamic Battery Fraction"
. }

. if `old_cost_curve' == 1{
.         local cc_def "Fixed Battery Fraction"
. }

. 
. local y_ub = `WTP_cc' + 0.3

. global note_`1' = ""

. global normalize_`1' = 1

. global yscale_`1' = "range(0 `y_ub')"

. 
. 
. if "${latex}" == "yes"{
.         if "`bev_cf'" == "clean_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output
.                 local outputs semie msrp net_msrp kwh_per_mile total_subsidy kwh
> _used_year_one total_bev_damages_glob ev_first_damages_g wtp_yes_ev_g wtp_no_ice
> _global_tot ///
>                                         wtp_no_ice_g wtp_glob wtp_loc wtp_soc_rb
> d marg_sales cum_sales batt_frac fixed_cost_frac gas_consumed_year_one total_bev
> _damages_glob_n ///
>                                         total_ice_damages_glob_n total_ice_damag
> es_loc total_ice_damages_loc_n batt_per_kwh_cost batt_cap env_cost_wtp cost_wtp 
> ///
>                                         tot_gal gas_markup wtp_prod_s WTP_cc tot
> _kwh util_producer_surplus wtp_prod_u total_bev_damages_loc_n total_damages_loc_
> n ///
>                                         avg_state_subsidy avg_fed_subsidy avg_st
> ate_subsidy_n avg_fed_subsidy_n fed_fisc_ext state_fisc_ext avg_subsidy beh_fisc
> _ext gas_fisc_ext tax_rate utility_fisc_ext util_gov_revenue fisc_ext_lr ///
>                                         total_cost MVPF epsilon semie_paper EV_i
> ncrease ep_avg_subsidy net_elas_msrp ev_cf_mpg avg_subsidy_n batt_emissions batt
> _damages_n batt_man_ext
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         if inlist("`i'", "msrp", "net_msrp", "marg_sales", "cum_
> sales", "batt_per_kwh_cost", "tot_kwh", "gas_consumed_year_one", "avg_subsidy", 
> "net_elas_msrp") | inlist("`i'", "tot_gal", "avg_state_subsidy") {
 10.                                 local `original' = trim("`: display %8.0gc ``
> original'''")
 11.                         }
 12.                         else if inlist("`i'", "avg_fed_subsidy", "total_subsi
> dy", "ep_avg_subsidy") {
 13.                                 local `original' = trim("`: display %5.2fc ``
> original'''")
 14.                         }
 15.                         else if inlist("`i'", "semie"){
 16.                                 local `original' = trim("`: display %5.4fc ``
> original'''")
 17.                         }
 18.                         else{
 19.                                 local `original' = trim("`: display %5.3fc ``
> original'''")
 20.                         }
 21.                         local command = "\newcommand{\\`newname'`1'`4'}{``ori
> ginal''}"
 22.                         di "`command'"
 23.                         file write myfile "`command'" _n
 24.                         
.                 }
.                 file close myfile
. 
.         }
. 
.         if "`bev_cf'" == "new_car" & ${sc_CO2_2020} == 193{
. 
.                 ** Latex Output with dirty counterfactual
.                 local outputs MVPF
.                 capture: file close myfile
.                 file open myfile using "${user}/Dropbox (MIT)/Apps/Overleaf/MVPF
>  Climate Policy/BEVandHEVAppendices/macros_`1'_`4'_dirty_cf.sty", write replace
.                 file write myfile "\NeedsTeXFormat{LaTeX2e}" _n
.                 file write myfile "\ProvidesPackage{macros_`1'_`4'_dirty_cf}" _n
.                 foreach i of local outputs{
  2. 
.                         local original = "`i'"
  3.                         local newname = "`i'"
  4. 
.                         // Remove underscores from the variable name
.                         while strpos("`newname'", "_"){
  5.                                 local newname = subinstr("`newname'", "_", ""
> , .)
  6.                         }
  7.                         local 1 = subinstr("`1'", "_", "", .)
  8.                         local 4 = subinstr("`4'", "_", "", .)
  9. 
.                         
.                         local `original' = trim("`: display %5.3fc ``original'''
> ")
 10.                         
.                         local command = "\newcommand{\\`newname'`1'`4'dirtycf}{`
> `original''}"
 11.                         di "`command'"
 12.                         file write myfile "`command'" _n
 13.                         
.                 }
.                 file close myfile
. 
.         }
. 
. }

. 
end of do-file
vmt_adjust: .6154440799999999
(6 vars, 5 obs)
(4 observations deleted)

. ********************************************************************************
> *****
. /*       0. Program: California Low-Income Electric Vehicle Subsidy            *
> /
. ********************************************************************************
> *****
. 
. /*
> Muehlegger, Erich, and David S. Rapson. 
> "Subsidizing low-and middle-income adoption of electric vehicles: Quasi-experime
> ntal evidence from California." 
> Journal of Public Economics 216 (2022): 104752.
> * https://www.sciencedirect.com/science/article/abs/pii/S0047272722001542
> */
. 
. display `"All the arguments, as typed by the user, are: `0'"'
All the arguments, as typed by the user, are: muehl_efmp no uncorrected_vJK curren
> t

. ********************************
. /* 0.5. Robustness Check Toggles */
. ********************************
. local marg_mvpf = 1

. local non_marg_mvpf = 0

. 
. local s_0 = 0

. local s_1 = 1

. local s_bar = 0

. 
. local new_cost_curve = 1

. local old_cost_curve = 0

. 
. local dynamic_grid = 1

. local static_grid = 0

. 
. local want_rebound = 1

. 
. local elec_dem_elas = -0.190144

. local elec_sup_elas = 0.7806420154513118

. 
. local bev_cf = "${bev_cf}"

. local veh_lifespan_type = substr("${bev_cf}", strpos("${bev_cf}", "_") + 1, .)

. 
. local simplified_wf = 0

. 
. ********************************
. /* 1. Pull Global Assumptions */
. ********************************
. * Project wide globals
. local discount = ${discount_rate}

. 
. *********************************
. /* 2. Estimates from Paper */
. *********************************
. /* Import estimates from paper, giving option for corrected estimates.
> When bootstrap!=yes import point estimates for causal estimates.
> When bootstrap==yes import a particular draw for the causal estimates. */
. 
. if "`1'" != "" global name = "`1'"

. local bootstrap = "`2'"

. if "`3'" != "" global folder_name = "`3'"

. if "`bootstrap'" == "yes" {
. *       if ${draw_number} ==1 {
.                 preserve
.                         use "${code_files}/2b_causal_estimates_draws/${folder_na
> me}/${ts_causal_draws}/${name}.dta", clear
.                         qui ds draw_number, not 
.                         global estimates_${name} = r(varlist)
.                         
.                         mkmat ${estimates_${name}}, matrix(draws_${name}) rownam
> es(draw_number)
.                 restore
. *       }
.         local ests ${estimates_${name}}
.         foreach var in `ests' {
  2.                 matrix temp = draws_${name}["${draw_number}", "`var'"]
  3.                 local `var' = temp[1,1]
  4.         }
. }

. if "`bootstrap'" == "no" {
.         preserve
.                 
. qui import excel "${code_files}/2a_causal_estimates_papers/${folder_name}/${name
> }.xlsx", clear sheet("wrapper_ready") firstrow  
. 
. levelsof estimate, local(estimates)
`"epsilon"' `"farmer_theta"' `"pass_through"'
. 
. 
. 
. 
.                 foreach est in `estimates' {
  2.                         su pe if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         2.1           .        2.1        2.1

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1       -.421           .      -.421      -.421

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
          pe |          1         .85           .        .85        .85
.         restore
. }

. if "`bootstrap'" == "pe_ci" {
.         preserve
.                 use "${code_files}/2b_causal_estimates_draws/${folder_name}/${ts
> _causal_draws}/${name}_ci_pe.dta", clear
.                 
. levelsof estimate, local(estimates)
. 
. 
.                 foreach est in `estimates' {
  2.                         sum ${val} if estimate == "`est'"
  3.                         local `est' = r(mean)
  4.                 }
.         restore 
. }

. 
. local farmer_theta = -0.421

. local pass_through = 0.85

. 
. ****************************************************
. /* 3. Set local assumptions unique to this policy */
. ****************************************************
. if "`4'" == "baseline" | "`4'" == "baseline_gen"{
.         global dollar_year = ${policy_year}
. }

. if "`4'" == "current"{
.         global dollar_year = ${current_year}
. }

. 
. global run_year = ${run_year}

. local dollar_year = ${dollar_year}

. 
. ****************************************************
. /* 3a. EV Counterfactual Vehicle Fuel Economy Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         forvalues y = 2015(1)2018{
  2.                 qui sum total_sales if year == `y'
  3.                 local total_sales`y' = r(mean)
  4.         }

.         if "`4'" == "baseline"{
.                 keep if year >= 2015 & year <= 2018
.                 forvalues y = 2015(1)2018{
  2.                         qui sum total_sales if year == `y'
  3.                         local total_sales`y' = r(mean)
  4.                         qui sum cf_mpg if year == `y'
  5.                         local cf_mpg_`y' = r(mean)
  6.                 }
.                 local ev_cf_mpg = (`total_sales2015' * `cf_mpg_2015' + `total_sa
> les2016' * `cf_mpg_2016' + `total_sales2017' * `cf_mpg_2017' + `total_sales2018'
>  * `cf_mpg_2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum cf_mpg
.                 local ev_cf_mpg = r(mean)
.         }

. restore

. 
. ****************************************************
. /* 3b. Gas Price and Tax Data */
. ****************************************************
. 
. 
. preserve

.         use "${gas_fleet_emissions}/fleet_year_final", clear

.         keep if fleet_year==${run_year}
(1 observation deleted)

.         
.         qui ds *_gal

.         foreach var in `r(varlist)' {
  2.                 replace `var' = `var'/1000000
  3.                 * Converting from grams per gallon to metric tons per gallon.
.                 qui sum `var'
  4.                 local `var' = r(mean)
  5.         }
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)
(0 real changes made)

. restore

. 
. preserve

.         use "${user_specific_assumptions}/files_v${user_name}/Gasoline Prices, M
> arkups, and Taxes/gas_data_final", clear

.                         
.         gen real_gas_price = gas_price*(${cpi_${dollar_year}} / index) 

.         gen real_tax_rate = avg_tax_rate*(${cpi_${dollar_year}} / index)

.         gen real_markup = markup * (${cpi_${dollar_year}} / index)

.                         
.         keep if year==${run_year}
(56 observations deleted)

.                 
.         local consumer_price = real_gas_price 

.         * Consumer price = includes taxes. 
.         local tax_rate = real_tax_rate

.         local markup = real_markup

.                 
.         if "${spec_type}" == "baseline" {
.                 qui import excel "${assumptions}/evs/processed/state_level_gas_t
> ax_rates", first clear
.                 keep tax2015 tax2016 tax2017 tax2018 state
.                 replace tax2015 = tax2015 * (${cpi_${dollar_year}} / ${cpi_2015}
> )
.                 replace tax2016 = tax2016 * (${cpi_${dollar_year}} / ${cpi_2016}
> )
.                 replace tax2017 = tax2017 * (${cpi_${dollar_year}} / ${cpi_2017}
> )
.                 replace tax2018 = tax2018 * (${cpi_${dollar_year}} / ${cpi_2018}
> )
.                 keep if state == "California"
.                 merge m:1 state using "${assumptions}/evs/processed/pop_by_state
> _2010_2019", keep(match)
.                 gen N = pop2015 + pop2016 + pop2017 + pop2018
.                 gen weighted_avg = pop2015 * tax2015 + pop2016 * tax2016 + pop20
> 17 * tax2017 + pop2018 * tax2018
.                 replace weighted_avg = weighted_avg / N
.                 sum weighted_avg 
.                 local tax_rate = r(mean) / 100
. 
.                 use "${gas_price_data}/gas_data_monthly", clear
.                 keep if inrange(year, 2015, 2018) // end year being 2018 is sus,
>  based on pg. 3 of paper
.                 drop if year == 2015 & month < 6
.                 * Muehlegger and Rapson 2022 look at BEV rebates for Q3 2015 thr
> ough Q4 2018. (uncertain about end date)
.                 * Calculate gas price for 2015 using only 6 months in 2015 sampl
> e. 
. 
.                 gen real_gas_price = gas_price * (${cpi_${dollar_year}} / index)
>  // no state-level gas price data so just gonna keep using national numbers
.                 gen real_markup = markup * (${cpi_${dollar_year}} / index)
. 
.                 collapse (mean) real*  [aw=gas_consumption]
.                 assert _n == 1
.                 local consumer_price = real_gas_price 
.                 * Consumer price = includes taxes.
.                 local markup = real_markup
.         }       

. restore

. 
. ****************************************************
. /* 3c. EV Specific Assumptions */
. ****************************************************
. preserve

.         qui import excel "${policy_assumptions}", first clear sheet("evs")

.                 
.         levelsof Parameter, local(levels)
`"corporate_tax"' `"ng_public"' `"utility_profit"' `"utility_public"' `"val_given"
> ' `"vehicle_avg_lifetime"' `"vehicle_car_lifetime"'

.         foreach val of local levels {
  2.                 qui sum Estimate if Parameter == "`val'"
  3.                 global `val' = `r(mean)'
  4.         }

.                 
.         local val_given = ${val_given}

.         
.         if "${vehicle_lifetime_change}" == "yes" {
.                 global vehicle_car_lifetime = ${new_vehicle_lifetime}
.         }

.         
.         local lifetime = ${vehicle_`veh_lifespan_type'_lifetime}

. restore

. 
. ****************************************************
. /* 3d. EV Energy Consumption Data */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum avg_kwh_per_mile if year == `y'
  3.                         local kwh_per_mile`y' = r(mean)
  4.                         qui sum avg_batt_cap if year == `y'
  5.                         local batt_cap`y' = r(mean)
  6.                 }
. 
.                 local kwh_per_mile = (`total_sales2015' * `kwh_per_mile2015' + `
> total_sales2016' * `kwh_per_mile2016' + `total_sales2017' * `kwh_per_mile2017' +
>  `total_sales2018' * `kwh_per_mile2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.                 local batt_cap = (`total_sales2015' * `batt_cap2015' + `total_sa
> les2016' * `batt_cap2016' + `total_sales2017' * `batt_cap2017' + `total_sales201
> 8' * `batt_cap2018') ///
>                                                         / (`total_sales2015' + `
> total_sales2016' + `total_sales2017' + `total_sales2018')
.         }

.         else{
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_kwh_per_mile
.                 local kwh_per_mile = r(mean)
.                 qui sum avg_batt_cap
.                 local batt_cap = r(mean)
.         }

. restore

. 
. 
. ****************************************************
. /*                  3e. EV Price Data             */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear

.         forvalues y = 2015(1)2018{
  2.                 replace avg_msrp = avg_msrp * (${cpi_2015} / ${cpi_`y'}) if y
> ear == `y'
  3.                 qui sum avg_msrp if year == `y'
  4.                 local msrp`y' = r(mean)
  5.         }
(0 real changes made)
(1 real change made)
(1 real change made)
(1 real change made)

.         * calculating fixed price in paper's sample period for use in calculatin
> g a constant elasticity
.         local elas_msrp = (`total_sales2015' * `msrp2015' + `total_sales2016' * 
> `msrp2016' + `total_sales2017' * `msrp2017' + `total_sales2018' * `msrp2018') //
> /
>                                         / (`total_sales2015' + `total_sales2016'
>  + `total_sales2017' + `total_sales2018')

.         if "`4'" == "baseline"{
.                 local msrp = `elas_msrp'
.         }

.         else{
.                 use "${assumptions}/evs/processed/kwh_msrp_batt_cap.dta", clear
.                 keep if year == ${run_year}
(9 observations deleted)
.                 qui sum avg_msrp
.                 local msrp = r(mean) * (${cpi_`dollar_year'} / ${cpi_${run_year}
> })
.         }

. restore

. 
. ****************************************************
. /* 3f. EV and ICE Age-State-Level VMT Data */
. ****************************************************
. local ub = `lifetime'

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ev_vmt_by_state_by_age", clear
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt_by_state_age[`y']
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ev_vmt_by_age", clear
.                 local ub = `lifetime'
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ev_miles_traveled`y' = vmt[`y']
  3.                 }
.         }

. restore

. 
. preserve

.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/ice_vmt_by_state_by_age", clea
> r
.                 keep if state == "CA"
.                 keep state age vmt_by_state_age
. 
.                 local ub = `lifetime'
.                 duplicates drop age vmt_by_state_age, force
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt_by_state_age[`y'] *
>  ${EV_VMT_car_adjustment}
  3.                 }
.         }

.         else{
.                 use "${assumptions}/evs/processed/ice_vmt_by_age", clear
.                 duplicates drop age vmt, force

Duplicates in terms of age vmt

(0 observations are duplicates)
.                 sort age
.                 forvalues y = 1(1)`ub'{
  2.                         local ice_miles_traveled`y' = vmt[`y'] * ${EV_VMT_car
> _adjustment}
  3.                 }
.         }       

. restore

. 
. ** Fixing EVs vmt at same levels as ICE
. forvalues y = 1(1)`ub'{
  2.         local ev_miles_traveled`y' = `ice_miles_traveled`y''
  3. }

. 
. ****************************************************
. /* 3g. Population Data */
. ****************************************************
. preserve

.         ** avg over policy's time period (2015-2018) for baseline
.         if "`4'" == "baseline"{
.                 use "${assumptions}/evs/processed/pop_by_state_2000_2019", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum pop`y' if state == "California"
  3.                         local CA_pop_`y' = r(mean)
  4.                 }
.         }

. restore

. 
. ****************************************************
. /* 3h. Cost Curve */
. ****************************************************
. preserve

.         use "${assumptions}/evs/processed/battery_sales_combined", clear

.         keep if year == `dollar_year'
(31 observations deleted)

.         qui sum cum_sales

.         local cum_sales = r(mean)

.         qui sum marg_sales

.         local marg_sales = r(mean)              

. restore

. 
. preserve

.         use "${assumptions}/evs/processed/cyl_batt_costs_combined", clear

.         if "`4'" == "baseline"{
.                 forvalues y = 2015(1)2018{
  2.                         qui sum prod_cost_2018 if year == `y'
  3.                         local prod_cost`y' = r(mean)
  4.                 }
.                 local prod_cost = (`total_sales2015' * `prod_cost2015' + `total_
> sales2016' * `prod_cost2016' + `total_sales2017' * `prod_cost2017' + `total_sale
> s2018' * `prod_cost2018') ///
>                                                 / (`total_sales2015' + `total_sa
> les2016' + `total_sales2017' + `total_sales2018')
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

.         else{
.                 keep if year == `dollar_year'
(31 observations deleted)
.                 qui sum prod_cost_2018
.                 local prod_cost = r(mean)
.                 local batt_per_kwh_cost = `prod_cost' * (${cpi_2020} / ${cpi_201
> 8})
.         }

. restore

. 
. ****************************************************
. /* 3i. Subsidy Levels */
. ****************************************************
. preserve

.         ** Federal Subsidy
. 
.         use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear

.         keep if year >= 2015 & year <= 2018
(8 observations deleted)

.         egen N = total(subsidy_N)

.         egen weighted_avg = total(subsidy_weighted_avg * subsidy_N)

.         replace weighted_avg = weighted_avg / N
(4 real changes made)

.         qui sum weighted_avg

.         local elas_avg_fed_subsidy = r(mean)

. 
.         if "`4'" == "baseline"{
.                 local avg_fed_subsidy = `elas_avg_fed_subsidy'
.         }

.         else{
.                 use "${assumptions}/evs/processed/bev_fed_subsidy_data", clear
.                 keep if year == ${run_year}
(11 observations deleted)
.                 qui sum subsidy_weighted_avg
.                 local avg_fed_subsidy = r(mean)
. 
.                 local avg_state_subsidy = 604.27 // see NST-EST2023-POP spreadsh
> eet in data/1_assumptions/evs
.         }

.         if "${ev_fed_subsidy}" != ""{
.                 if ${ev_fed_subsidy} != -1 {
.                         local avg_fed_subsidy = ${ev_fed_subsidy}
.                 }
.         }

. restore

. 
. ****************************************************
. /* 4. Set local assumptions unique to this policy */
. ****************************************************
. ** Cost assumptions:
. * Program costs - US$
. if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.         local rebate_cost = 9000 // Average subsidy (cf. text p. 8)
. }

. else if `s_0' == 1{
.         local rebate_cost = 0
. }

. else if `s_bar' == 1{
.         local rebate_cost = 9000 / 2
. }

. local adj_rebate_cost = `rebate_cost' * (${cpi_`dollar_year'} / ${cpi_${policy_y
> ear}})

. local avg_subsidy = `adj_rebate_cost'

. local elas_avg_subsidy = `rebate_cost' // state subsidy, always want this in the
>  policy year's dollars

. 
. if "`4'" != "baseline"{
.         if (`s_1' == 1 & `marg_mvpf' == 1) | (`non_marg_mvpf' == 1){
.                 local avg_subsidy = `avg_state_subsidy'
.         }
.         else if `s_0' == 1{
.                 local avg_subsidy = 0
.         }
.         else if `s_bar' == 1{
.                 local avg_subsidy = `avg_state_subsidy' / 2
.         }
. }

. 
. ****************************************************
. /*          5. Intermediate Calculations          */
. ****************************************************
. 
. local net_elas_msrp = `elas_msrp' - `elas_avg_fed_subsidy' - 0.5 * `elas_avg_sub
> sidy'

. local epsilon = -`epsilon' // make it negative for the cost curve

. 
. local net_msrp = `msrp' - `avg_subsidy' - `avg_fed_subsidy'

. local total_subsidy = `avg_subsidy' + `avg_fed_subsidy'

. local semie = -`epsilon' / `net_msrp' // the negative sign makes this value posi
> tive

. 
. if `marg_mvpf' == 1{
.         local beh_response = `semie' * `pass_through'
. }

. else if `non_marg_mvpf' == 1{
.         local beh_response = `semie' * `avg_subsidy'
. }

. 
. * oil producers
. local producer_price = `consumer_price' - `tax_rate'

. local producer_mc = `producer_price' - `markup'

. 
. * utility companies
. if "`4'" == "baseline"{
.         local util_gov_revenue = (`CA_pop_2015'* ${government_revenue_2015_CA} +
>  `CA_pop_2016'* ${government_revenue_2016_CA} + `CA_pop_2017'* ${government_reve
> nue_2017_CA} + `CA_pop_2018'* ${government_revenue_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
.         local util_producer_surplus = (`CA_pop_2015'* ${producer_surplus_2015_CA
> } + `CA_pop_2016'* ${producer_surplus_2016_CA} + `CA_pop_2017'* ${producer_surpl
> us_2017_CA} + `CA_pop_2018'* ${producer_surplus_2018_CA}) ///
>                                                                 / (`CA_pop_2015'
>  + `CA_pop_2016' + `CA_pop_2017' + `CA_pop_2018')
. }

. 
. else{
.         local util_gov_revenue ${government_revenue_`dollar_year'_${State}}
.         local util_producer_surplus ${producer_surplus_`dollar_year'_${State}}
. }

. 
. **************************
. /* 6. Cost Calculations  */
. **************************
. 
. * Program cost
. if `marg_mvpf' == 1{
.         local program_cost = 1
. }

. else if `non_marg_mvpf' == 1{
.         local program_cost = (1 + `beh_response') * `avg_subsidy'
. }

. 
. local utility_fisc_ext = 0

. forvalues y = 1(1)`ub'{
  2.         local utility_fisc_ext = `utility_fisc_ext' + (`beh_response' * `ev_m
> iles_traveled`y'' * `kwh_per_mile' * `util_gov_revenue') / ((1 + `discount')^(`y
> ' - 1)) // gain in profit tax from highter utility profits + gain in gov revenue
>  since 28% of utilities are publicly owned
  3. }

. 
. if "`4'" == "baseline"{
.         local gas_fisc_ext = 0
.         forvalues y = 1(1)`ub'{
  2.                 local gas_fisc_ext = `gas_fisc_ext' + ((`beh_response' * (`ic
> e_miles_traveled`y'' / `ev_cf_mpg') * `tax_rate') / ((1+`discount')^(`y' - 1)))
  3.         }
. }

. else{
.         local gas_fisc_ext = `beh_response' * ${`bev_cf'_cf_gas_fisc_ext_`dollar
> _year'}
.         local tax_rate = ${nominal_gas_tax_`dollar_year'} // for Latex
. }

. 
. 
. local fed_fisc_ext = `beh_response' * `avg_fed_subsidy'

. local avg_fed_subsidy_n = `avg_fed_subsidy' / `net_msrp'

. 
. local beh_fisc_ext = `semie' * `avg_subsidy'

. 
. if `marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext' + `beh_fisc_ext'
. }

. else if `non_marg_mvpf' == 1{
.         local total_cost = `program_cost' - `utility_fisc_ext' + `gas_fisc_ext' 
> + `fed_fisc_ext'
. }

. 
. 
. *************************
. /* 7. WTP Calculations */
. *************************
. 
. * consumers
. local wtp_cons = `pass_through'

. * dealers/car manufacturers
. local wtp_deal = (1 - `pass_through')

. 
. * marginal and inframarginal consumers/dealers (?)
. local wtp_marg = 0.5 * `beh_response' * `avg_subsidy'

. local wtp_inf = `avg_subsidy'

. 
. local wtp_prod_u = 0

. local wtp_prod_s = 0

. 
. if "${value_profits}" == "yes"{
. 
.         if "`4'" == "baseline"{
.                 local tot_gal = (${`bev_cf'_gal_2015} * `total_sales2015' + ${`b
> ev_cf'_gal_2016} * `total_sales2016' + ${`bev_cf'_gal_2017} * `total_sales2017' 
> + ${`bev_cf'_gal_2018} * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
.                 local gas_markup = (${nominal_gas_markup_2015} * (${cpi_${dollar
> _year}} / ${cpi_2015}) * `total_sales2015' + ${nominal_gas_markup_2016} * (${cpi
> _${dollar_year}} / ${cpi_2016}) * `total_sales2016' + ${nominal_gas_markup_2017}
>  * (${cpi_${dollar_year}} / ${cpi_2017}) * `total_sales2017' + ${nominal_gas_mar
> kup_2018} * (${cpi_${dollar_year}} / ${cpi_2018}) * `total_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018') // f
> or Latex
. 
.                 local wtp_prod_s = 0
.                 forvalues y = 1(1)`ub'{
  2.                         local wtp_prod_s = `wtp_prod_s' + ((`beh_response' * 
> (`ice_miles_traveled`y'' / `ev_cf_mpg') * (`producer_price' - `producer_mc')) / 
> ((1 + `discount')^(`y' - 1))) // positive
  3.                 }
.         }
. 
.         else{
.                 local tot_gal = ${`bev_cf'_gal_`dollar_year'} // for Latex
.                 local gas_markup = ${nominal_gas_markup_`dollar_year'} // for La
> tex
. 
.                 local wtp_prod_s = `beh_response' * ${`bev_cf'_wtp_prod_s_`dolla
> r_year'} 
. 
.         }
. 
.         * producers - utilities
.         local wtp_prod_u = 0
.         local tot_kwh = 0
. 
.         forvalues y = 1(1)`ub'{
  2.                 local tot_kwh = `tot_kwh' + (`ev_miles_traveled`y'' * `kwh_pe
> r_mile') // for Latex
  3.                 local wtp_prod_u = `wtp_prod_u' + ((`beh_response' * (`ev_mil
> es_traveled`y'' * `kwh_per_mile') * `util_producer_surplus') / ((1 + `discount')
> ^(`y' - 1)))
  4.         }
. }

. 
. ** take out the corporate effective tax rate
. local total_wtp_prod_s = `wtp_prod_s'

. local wtp_prod_s = `total_wtp_prod_s' * (1 - 0.21)

. local gas_corp_fisc_e = `total_wtp_prod_s' * 0.21

. 
. local profits_fisc_e = `gas_corp_fisc_e' - `utility_fisc_ext'

. 
. if `marg_mvpf' == 1{
.         local wtp_private = `wtp_cons' + `wtp_deal' - `wtp_prod_s' + `wtp_prod_u
> '
. }

. else if `non_marg_mvpf' == 1{
.         local wtp_private = `wtp_marg' + `wtp_inf' - `wtp_prod_s' + `wtp_prod_u'
. }

. 
. 
. * learning by doing
. local prod_cost = `prod_cost' * (${cpi_`dollar_year'} / ${cpi_2018}) // data is 
> in 2018USD

. 
. local batt_cost = `prod_cost' * `batt_cap'

. local batt_frac = `batt_cost' / `msrp'

. 
. local fixed_cost_frac = 1 - `batt_frac'

. 
. local car_theta = `farmer_theta' * `batt_frac'

. 
. 
. ** Externality and WTP for driving a battery electric vehicle
. 
. if "`4'" == "baseline"{
. 
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         
.         *** dynamic grid stuff
.         local kwh_used `ev_miles_traveled1' * `kwh_per_mile'
.         local end_year = `dollar_year' + `ub' - 1
.         local i = 1
.         forvalues y = `dollar_year'(1)`end_year'{
  2.                 dynamic_split_grid `kwh_used', starting_year(`dollar_year') e
> xt_year(`y') discount_rate(`discount') ef(${replacement}) geo("${State}") type("
> uniform") grid_specify("yes") model(${grid_model})
  3.                 if `i' == 1{
  4.                         local ev_first_damages_g = `r(global_enviro_ext)' // 
> for Latex
  5.                 }
  6.                 local i = `i' + 1
  7.                 local kwh_used `ev_miles_traveled`i'' * `kwh_per_mile'
  8.                 local local_benefit = `local_benefit' + `r(local_enviro_ext)'
  9.                 local global_benefit = `global_benefit' + `r(global_enviro_ex
> t)'
 10. 
.                 local carbon_content = `carbon_content' + `r(carbon_content)'
 11.                 local q_carbon_yes_ev = -`beh_response' * `carbon_content'
 12.                 local q_carbon_yes_ev_mck = -`carbon_content'
 13.         }
.         local total_bev_damages_glob = `global_benefit' // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -`local_benefit' / `net_msrp' // for Lat
> ex
. 
.         local wtp_yes_ev_local = -`beh_response' * `local_benefit'
.         local wtp_yes_ev_global_tot = -`beh_response' * `global_benefit'
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_
> r_`dollar_year'}
.         local us_wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_glob
> al_no_r_`dollar_year'} 
.         local us_wtp_yes_ev_g = `us_wtp_yes_ev_global_tot' * ((1 - ${USShareFutu
> reSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_yes_ev = `us_wtp_yes_ev_local' + `us_wtp_yes_ev_g'
. }

. 
. 
. else{
.         local kwh_used_year_one = `ev_miles_traveled1' * `kwh_per_mile' // for L
> atex
.         local total_bev_damages_glob = ${yes_ev_damages_global_no_r_`dollar_year
> '} // for Latex
.         local total_bev_damages_glob_n = `total_bev_damages_glob' / `net_msrp' /
> / for Latex
.         local total_bev_damages_loc_n = -${yes_ev_damages_local_no_r_`dollar_yea
> r'} / `net_msrp' // for Latex
.         if "${latex}" == "yes"{
.                 local ev_first_damages_g = ${ev_first_damages_g_2020} // for Lat
> ex
.         }
.         
.         local wtp_yes_ev_local = -`beh_response' * ${yes_ev_damages_local_no_r_`
> dollar_year'}
.         local wtp_yes_ev_global_tot = -`beh_response' * ${yes_ev_damages_global_
> no_r_`dollar_year'}
.         local wtp_yes_ev_g = `wtp_yes_ev_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local q_carbon_yes_ev = -`beh_response' * ${yes_ev_carbon_content_`dolla
> r_year'}
.         local q_carbon_yes_ev_mck = -${yes_ev_carbon_content_`dollar_year'}
. }

. 
. local yes_ev_local_ext = `wtp_yes_ev_local' / `beh_response'

. local yes_ev_global_ext_tot = `wtp_yes_ev_global_tot' / `beh_response'

. 
. local wtp_yes_ev = `wtp_yes_ev_local' + `wtp_yes_ev_g'

. 
. local yes_ev_ext = `wtp_yes_ev' / `beh_response'

. 
. ** Calculating the gallons used in the first year of a vehicle's lifetime for La
> tex
. preserve

. 
.         if "`4'" == "baseline"{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 forvalues y = 2015(1)2018{
  2.                         qui sum `bev_cf'_mpg if year == `y'
  3.                         local cf_mpg_`y' = `r(mean)'
  4. 
.                         local gas_consumed_year_one_`y' = `vmt_age_1' / `cf_mpg_
> `y''
  5.                 }
. 
.                 local gas_consumed_year_one = (`gas_consumed_year_one_2015' * `t
> otal_sales2015' + `gas_consumed_year_one_2016' * `total_sales2016' + `gas_consum
> ed_year_one_2017' * `total_sales2017' + `gas_consumed_year_one_2018' * `total_sa
> les2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. 
.         }

. 
.         else{
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vmt_dist_car.dta", clear
.                 qui sum vmt_avg_car if age == 1
.                 local vmt_age_1 = `r(mean)'
. 
.                 use "${user_specific_assumptions}/files_v${user_name}/Vehicle Li
> fetime Damages/vehicles_${scc_ind_name}_${dr_ind_name}_rbd_${hev_cf}.dta", clear
.                 qui sum `bev_cf'_mpg if year == 2020
.                 local cf_mpg_2020 = `r(mean)'
. 
.                 local gas_consumed_year_one = `vmt_age_1' / `cf_mpg_2020'
.         }

. 
. restore

. 
. ** Externality and WTP for driving an ICE vehicle
. 
. if "`4'" == "baseline"{
.         local wtp_no_ice_local = `beh_response' * ((${`bev_cf'_cf_damages_loc_20
> 15} * `total_sales2015' + ${`bev_cf'_cf_damages_loc_2016} * `total_sales2016' + 
> ${`bev_cf'_cf_damages_loc_2017} * `total_sales2017' + ${`bev_cf'_cf_damages_loc_
> 2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
. 
.         local wtp_no_ice_global_tot = `beh_response' * ((${`bev_cf'_cf_damages_g
> lob_2015} * `total_sales2015' + ${`bev_cf'_cf_damages_glob_2016} * `total_sales2
> 016' + ${`bev_cf'_cf_damages_glob_2017} * `total_sales2017' + ${`bev_cf'_cf_dama
> ges_glob_2018} * `total_sales2018') ///
>                                                                                 
>                  / (`total_sales2015' + `total_sales2016' + `total_sales2017' + 
> `total_sales2018'))
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / (`beh_response'
> ) // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / (`beh_response') // f
> or Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
. 
.         local q_carbon_no_ice = `beh_response' * ((${`bev_cf'_cf_carbon_2015} * 
> `total_sales2015' + ${`bev_cf'_cf_carbon_2016} * `total_sales2016' + ${`bev_cf'_
> cf_carbon_2017} * `total_sales2017' + ${`bev_cf'_cf_carbon_2018} * `total_sales2
> 018') / (`total_sales2015' + `total_sales2016' + `total_sales2017' + `total_sale
> s2018'))
.         local q_carbon_no_ice_mck = `q_carbon_no_ice' / `beh_response'
. 
.         
.         ** need US-wide stuff for scaling cost curve outputs
.         local us_wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`
> dollar_year'}
.         local us_wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_
> glob_`dollar_year'} 
.         local us_wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureS
> SC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         local us_wtp_no_ice = `us_wtp_no_ice_local' + `us_wtp_no_ice_g'
. }

. else{
.         local wtp_no_ice_local = `beh_response' * ${`bev_cf'_cf_damages_loc_`dol
> lar_year'}
.         local wtp_no_ice_global_tot = `beh_response' * ${`bev_cf'_cf_damages_glo
> b_`dollar_year'}
.         local wtp_no_ice_g = `wtp_no_ice_global_tot' * ((1 - ${USShareFutureSSC}
> ) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
. 
.         local total_ice_damages_glob = `wtp_no_ice_global_tot' / `beh_response' 
> // for Latex
.         local total_ice_damages_glob_n = `total_ice_damages_glob' / `net_msrp' /
> / for Latex
.         local total_ice_damages_loc = `wtp_no_ice_local' / `beh_response' // for
>  Latex
.         local total_ice_damages_loc_n = `total_ice_damages_loc' / `net_msrp' // 
> for Latex
.         local total_damages_loc_n = `total_bev_damages_loc_n' + `total_ice_damag
> es_loc_n' // for Latex
. 
.         local q_carbon_no_ice = `beh_response' * ${`bev_cf'_cf_carbon_`dollar_ye
> ar'}
.         local q_carbon_no_ice_mck = ${`bev_cf'_cf_carbon_`dollar_year'}
. }

. 
. local no_ice_local_ext = `wtp_no_ice_local' / `beh_response'

. local no_ice_global_ext_tot = `wtp_no_ice_global_tot' / `beh_response'

. 
. local wtp_no_ice = `wtp_no_ice_local' + `wtp_no_ice_g'

. 
. if "`4'" == "baseline"{
.         local us_wtp_local = `us_wtp_yes_ev_local' + `us_wtp_no_ice_local'
.         local us_wtp_g = `us_wtp_yes_ev_g' + `us_wtp_no_ice_g'
. }

. 
. local no_ice_ext = `wtp_no_ice' / `beh_response'

. 
. *** Battery manufacturing emissions, 59.5 kg CO2eq/kWh for NMC111 batteries ***
. 
. * Averaging the SCC for 2015-2018
. if "`4'" == "baseline"{
.         local relevant_scc = (${sc_CO2_2015} * `total_sales2015' + ${sc_CO2_2016
> } * `total_sales2016' + ${sc_CO2_2017} * `total_sales2017' + ${sc_CO2_2018} * `t
> otal_sales2018') ///
>                                                                           / (`to
> tal_sales2015' + `total_sales2016' + `total_sales2017' + `total_sales2018')
. }

. else{
.         local relevant_scc = ${sc_CO2_`dollar_year'}
. }

. 
. local batt_emissions = 59.5 * `batt_cap' // for Latex, 59.5 from Winjobi et al. 
> (2022)

. 
. local batt_damages = `batt_emissions' * 0.001 * `relevant_scc'

. local batt_damages_n = (`batt_emissions' * 0.001 * `relevant_scc') / `net_msrp'

. 
. local batt_man_ext = `batt_emissions' * 0.001 * `beh_response' * `relevant_scc' 
> * ((1 - ${USShareFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC
> }))

. 
. local batt_man_ext_tot = `batt_emissions' * 0.001 * `beh_response' * `relevant_s
> cc'

. 
. local wtp_soc = `wtp_yes_ev' + `wtp_no_ice' - `batt_man_ext'

. 
. local us_wtp_g = `us_wtp_g' - `batt_man_ext' // nothing location specific for ba
> ttery emissiosn, so the externality is the same for the in-context estimate and 
> the US-wide 2011-14 estimate 

. local wtp_glob = `wtp_yes_ev_g' + `wtp_no_ice_g' - `batt_man_ext'

. local wtp_loc = `wtp_yes_ev_local' + `wtp_no_ice_local'

. 
. if "`4'" == "baseline"{
.         local us_wtp_soc = `us_wtp_yes_ev' + `us_wtp_no_ice'
. }

. 
. if `want_rebound' == 1{
.         ** rebound effect
.         local rbd_coeff = (1 / (1 - (`elec_dem_elas'/`elec_sup_elas')))
.         local wtp_soc_rbd =  -(1 - `rbd_coeff') * `wtp_yes_ev'
.         local wtp_soc_rbd_l = -(1 - `rbd_coeff') * `wtp_yes_ev_local'
.         local wtp_soc_rbd_global_tot = -(1 - `rbd_coeff') * `wtp_yes_ev_global_t
> ot'
.         local wtp_soc_rbd_g = -(1 - `rbd_coeff') * `wtp_yes_ev_g'
.         
.         local q_carbon_rbd = -(1 - `rbd_coeff') * `q_carbon_yes_ev'
.         local q_carbon_rbd_mck = -(1 - `rbd_coeff') * `q_carbon_yes_ev_mck'
.         
.     * Adding the rebound effect to the utility producer WTP
.     local wtp_private = `wtp_private' - (1 - `rbd_coeff') * `wtp_prod_u'
.         local wtp_prod_u = `rbd_coeff' * `wtp_prod_u' 
. 
.         * Adding the rebound effect to the utility fiscal externality
.         local total_cost = `total_cost' + (1 - `rbd_coeff') * `utility_fisc_ext'
.         local utility_fisc_ext =  `utility_fisc_ext' - (1 - `rbd_coeff') * `util
> ity_fisc_ext' // rebound makes the utility fe smaller
.     
. }

. 
. local local_enviro_ext = (`wtp_no_ice_local' + `wtp_yes_ev_local') / `beh_respon
> se'

. local global_enviro_ext_tot = (`wtp_no_ice_global_tot' + `wtp_yes_ev_global_tot'
> ) / `beh_response'

. 
. 
. local enviro_ext = `wtp_soc' / `beh_response'

. local enviro_ext_l = `wtp_loc' / `beh_response'

. local enviro_ext_g = `wtp_glob' / `beh_response'

. 
. if "`4'" == "baseline"{
.         local us_enviro_ext = `us_wtp_soc' / `beh_response'
.         local us_enviro_ext_l = `us_wtp_local' / `beh_response'
.         local us_enviro_ext_g = `us_wtp_g' / `beh_response'
. }

. 
. local prod_cost = `prod_cost' * `batt_cap' // cost of a battery in a car as oppo
> sed to cost per kWh

. 
. * learning-by-doing
. 
. *temporary solution -> if bootstrap gets a positive elasticity, hardcode epsilon
. if `epsilon' > 0{
.         local epsilon = -0.001
. }

. 
. 
. local dyn_enviro_global_tot = 0

. local env_cost_wtp_global_tot = 0

. local cost_wtp = 0

. local env_cost_wtp = 0

. local env_cost_wtp_l = 0

. local env_cost_wtp_g = 0

. local dyn_price = 0

. 
. if "${lbd}" == "yes"{
.         local lbd_cf = ("`bev_cf'" == "new_car")
.         ** --------------------- COST CURVE --------------------- **
.         if "`4'" == "baseline"{
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') /// 
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_local = `r(enviro_mvpf)' * (`enviro_ext_l' / `u
> s_enviro_ext_l')
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) ///
>                                                            start_year(`dollar_ye
> ar') scc(${scc_import_check}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment})
.                 local dyn_enviro_global_tot = `r(enviro_mvpf)' * (`enviro_ext_g'
>  / `us_enviro_ext_g')
.                 local dyn_enviro_global = `dyn_enviro_global_tot' * ((1 - ${USSh
> areFutureSSC}) + ${USShareFutureSSC} * (1 - ${USShareGovtFutureSCC}))
.         }
.         else{
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_local) time_path_age(`lifet
> ime') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
.                 local dyn_enviro_local = `r(enviro_mvpf)'
. 
.                 cost_curve_masterfile, demand_elas(`epsilon') discount_rate(`dis
> count') farmer(`farmer_theta') fcr(`fixed_cost_frac') ///
>                                                            curr_prod(`marg_sales
> ') cum_prod(`cum_sales') price(`net_msrp') enviro(ev_global) time_path_age(`life
> time') ///
>                                                            scc(${scc_import_chec
> k}) new_car(`lbd_cf') vmt(${EV_VMT_car_adjustment}) ev_grid(${ev_grid})
--Break--
r(1);
--Break--
r(1);
--Break--
r(1);

end of do-file
--Break--
r(1);

end of do-file
--Break--
r(1);

end of do-file

--Break--
r(1);

. di ${bev_m_low}
1.2117

